<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>codemill</title>
    <!-- Load required Bootstrap and BootstrapVue CSS -->
    <link type="text/css" rel="stylesheet" href="static/bootstrap.min.css" crossorigin="anonymous" />
    <link type="text/css" rel="stylesheet" href="static/bootstrap-vue.min.css" crossorigin="anonymous" />
    <!-- Load polyfills to support older browsers -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es2015%2CIntersectionObserver"></script>
    <!-- Load Vue followed by BootstrapVue -->
    <!-- VueJS development version, includes helpful console warnings -->
    <script src="static/vue.js" crossorigin="anonymous"></script>
    <script src="static/bootstrap-vue.min.js" crossorigin="anonymous"></script>
    <!-- Load the following for BootstrapVueIcons support -->
    <script src="static/bootstrap-vue-icons.min.js" crossorigin="anonymous"></script>
    <style type="text/css">
    .hidden {
        display: none;
    }

    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }

    .modal-dialog {
        max-width: 100%;
        margin: 0;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        border-radius: 0px;
        max-width: auto !important;
        max-height: auto !important;
        height: auto;
        min-height: 100%;
    }

    .modal-content {
        max-width: 100%;
        margin: 0;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        border-radius: 0px;
        padding: 0px;
        max-width: auto !important;
        max-height: auto !important;
        height: auto;
        min-height: 100%;
        max-height: fit-content !important;
    }

    .tab-pane {
        padding-left: 0px;
        padding-right: 0px;
    }

    .list-group-item {
        padding: 0.50rem 0.80rem;
    }

    .documentation {
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
        font-size: 0.9em;
        line-height: 1.42;
        white-space: pre;
        word-break: normal;
        box-sizing: border-box;
        color: #006600;
    }

    .text-comment {
        color: #007bff !important;
    }

    .selected {
        background-color: #28a745 !important;
        border-radius: 0.3em;
    }
    .selected-primary {
        color: #004085 !important;
        background-color: #cce5ff !important;
        border-color: #b8daff !important;
        border-radius: 0.3em;
    }
    .selected-success {
        color: #155724 !important;
        background-color: #d4edda !important;
        border-color: #c3e6cb !important;
        border-radius: 0.3em;
    }
    .selected-warning {
        color: #856404 !important;
        background-color: #fff3cd !important;
        border-color: #ffeeba !important;
        border-radius: 0.3em;
    }
    .custom-control-label {
      cursor: pointer;
    }

    .b-table-sticky-header,
    .table-responsive,
    [class*=table-responsive-] {
        margin-bottom: 0rem;
    }

    .comment-cell {
        padding: 0em !important;
        line-height: 1em;
    }

    .checkbox-cell {
        white-space: nowrap !important;
        float: none !important;
    }

    .skeleton-na {
        background-color: rgba(0, 0, 0, 0.06);
        cursor: auto;
    }

    .error-no-selectors {
      color: red !important;
    }
    .error-no-selectors::before {
      content: "Error: No selectors";
    }
    .checkbox-success > .custom-control-input:checked~.custom-control-label::before{
      background-color: #28a745 !important;
    }
    .checkbox-warning > .custom-control-input:checked~.custom-control-label::before {
      color: #212529 !important;
      background-color: #ffc107 !important;
    }
    .xmodel {
      border: 3px solid;
      border-radius: 0.1em;
      padding: 0.6em;
      margin-top: 1.5em;
      color: #004085;
      border-color: #009432;
    }
    .xmodel:hover {
      background-color: #cce5ff;
    }
    .default-margin-top {
      margin-top: 0.6em !important;
    }
    .xmethod {
      border: 2px solid;
      border-radius: 0.1em;
      padding: 0.6em;
      margin: 0.1em;
      color: #0c5460;
      border-color: #A3CB38;
    }
    .xmethod:hover {
      background-color: #c8d6e5;
    }
    .xselector {
      border: 1px solid;
      border-radius: 0.1em;
      padding: 1.3em;
      margin: 0.3em;

      color: #1B1464;
      border-color: #D980FA;
      position: relative;
    }
    .xselector:hover {
      background-color: #9980FA;
    }
    .package-indication {
        position: absolute;
        right: 0.3em;
        top: 0.15em;
        font-weight: bolder;
        font-style: initial;
        font-size: 1em;
        color: #341f97;
    }
    .package-indication:hover {
      cursor: pointer;
      text-decoration: underline;
    }
    .hover-field {
      cursor: default;
      padding: 0.1em;
    }
    .hover-field:hover {
      background-color: #ff9ff3;
      cursor: default;
    }
    .text-large {
      font-size: large;
    }
    [v-cloak] {
      display: none;
    }
    .flow-block {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
        padding: 0.8em;
        padding-left: 2em;
        padding-right: 2em;
        border: 2px solid;
        -moz-outline-radius: 10px;
        -webkit-outline-radius: 10px;
        -webkit-border-radius: 4px;
        -moz-border-radius: 4px;
        border-radius: 4px;
        width: fit-content;
        position: relative;
    }
    div.text-muted * {
        color: #6c757d !important;
    }
    .flow-block-index-indicator {
      position: absolute;
      left: 0.5em;
      top: 0.15em;
      font-weight: bolder;
      font-style: initial;
      font-size: 1em;
    }
    .flow-block-trash-icon {
      position: absolute;
      right: 0.5em;
      top: 0.5em;
    }
    </style>
</head>

<body>
    <div id="codemill-app" v-cloak>
        <b-overlay :show="isBusy.loadCode" rounded="lg" no-wrap fixed opacity="0.7" z-index="2000">
            <template #overlay>
                <div class="text-center">
                    <b-icon icon="cloud-download" font-scale="2" animation="fade" variant="primary"></b-icon>
                    <p>Loading <b>{{currentPackage.path}}{{fmtv(currentPackage.version)}}</b> ...</p>
                    <p>(This may take a while...)</p>
                </div>
            </template>
        </b-overlay>


        <b-container fluid v-if="!isBusy.xspec">
            <div>spec <b class="text-large">{{xspec.Name}}</b> (len = {{len(xspec.Models)}} models) {</div>
            <cm-xmodel v-for="(item, key) in xspec.Models" v-bind:key="key" v-bind:xmodel="item" class="ml-2" v-bind:class="{'default-margin-top': key == 0}"></cm-xmodel>

            <b-row class="ml-1" v-if="!newModel.show">
              <b-button variant="outline-primary" size="sm" @click="newModel.show = true" class="ml-1 mt-2"><b-icon icon="plus-square"></b-icon> Add a model</b-button>
            </b-row>
            <b-row class="mr-1" v-if="newModel.show">
              <div class="ml-3">
                <b-form inline>
                  <label class="mr-sm-2" for="inline-form-custom-select-pref">Model:</label>
                  <b-form-select
                    id="inline-form-custom-select-pref"
                    class="mb-2 mr-sm-2 mb-sm-0"
                    :options="modelKinds"
                    :value="null"
                    v-model="newModel.kind"
                    required
                    :state="newModel.kind != ''"
                  ></b-form-select>

                  <b-form-input
                    id="inline-form-input-name"
                    class="mb-2 mr-sm-2 mb-sm-0"
                    placeholder="Name"
                    v-model="newModel.name"
                    :state="newModel.name != ''"
                  ></b-form-input>

                  <b-button variant="success" size="sm" @click="spec_VerifyPushModel">+ Push</b-button>
                </b-form>
              </div>
            </b-row>

            <div>}</div>
        </b-container>
        <!-- Content here -->
        <b-container>
            <!-- Modal for searching packages -->
            <template>
                <b-modal id="modal-list-remote-packages" scrollable hide-footer title="Search packages" size="xl" no-close-on-backdrop @show="loadCachedVersionList">
                    <span v-if="len(cacheModules) > 0">Recently used:</span>
                    <b-list-group v-bind:class="{ hidden: !isBusy.cacheModules }">
                        <b-list-group-item><b-skeleton animation="wave" width="33%" type="input"></b-skeleton></b-list-group-item>
                        <b-list-group-item><b-skeleton animation="wave" width="59%" type="input"></b-skeleton></b-list-group-item>
                        <b-list-group-item><b-skeleton animation="wave" width="49%" type="input"></b-skeleton></b-list-group-item>
                    </b-list-group>
                    <b-list-group v-bind:class="{ hidden: isBusy.cacheModules }">
                      <cm-cached-module v-for="(item, key) in cacheModules" v-bind:key="revf(item.Path, item.Version)" v-bind:cached="item" class="ml-2"></cm-cached-module>
                    </b-list-group>
                    <b-form v-on:submit.prevent="search">
                        <label for="search-input-field">Search</label>
                        <b-overlay :show="isBusy.search" rounded="lg" opacity="0.6">
                            <div>
                                <b-input-group class="mt-3">
                                    <b-form-input type="search" id="search-input-field" v-model="searchData.current" class="mr-sm-6" aria-describedby="search-help-block"></b-form-input>
                                    <b-input-group-append>
                                        <b-button variant="primary" @click="search" :disabled="isBusy.search">{{isBusy.search ? "Searching..." : "Search" }}</b-button>
                                    </b-input-group-append>
                                </b-input-group>
                            </div>
                        </b-overlay>
                        <b-form-text id="search-help-block">
                            Search public Go packages.
                        </b-form-text>
                        <b-list-group v-bind:class="{ hidden: !isBusy.search }">
                            <b-list-group-item>
                                <b-skeleton animation="wave" width="85%" type="input"></b-skeleton>
                            </b-list-group-item>
                            <b-list-group-item>
                                <b-skeleton animation="wave" width="55%" type="input"></b-skeleton>
                            </b-list-group-item>
                            <b-list-group-item>
                                <b-skeleton animation="wave" width="70%" type="input"></b-skeleton>
                            </b-list-group-item>
                        </b-list-group>
                        <b-list-group v-bind:class="{ hidden: isBusy.search }">
                            <span class="float-left d-inline-block" v-if="len(searchData.results) == 0" variant="danger">
                                No results were found.
                            </span>
                            <cm-search-result v-for="(item, index) in searchData.results" v-bind:key="item.path + index" v-bind:item="item" v-bind:index="index"></cm-search-result>
                        </b-list-group>
                    </b-form>
                    <template #modal-footer>
                        <div class="w-100">
                            <b-button variant="secondary" class="float-right" size="sm" @click="$bvModal.hide('modal-list-remote-packages')">
                                Close
                            </b-button>
                        </div>
                    </template>
                </b-modal>
            </template>
        </b-container>
        <b-container>
            <template>
                <b-modal id="modal-show-code" scrollable hide-footer title="Code" size="xl" lazy no-close-on-backdrop @hidden="loadCachedVersionList">
                    <template #modal-title>
                        Source of <b>{{currentPackage.path}}{{fmtv(currentPackage.version)}}</b>
                        <small class="text-muted" v-if="currentPackage.source && currentPackage.source.Module">({{currentPackage.source.Module.Time}})</small>
                        <br>
                        <span class="text-muted d-flex">
                          You're currently editing&nbsp;<span class="text-monospace">model::<b>{{context.modelName}}</b></span>&nbsp;&gt;&nbsp;<span class="text-monospace">method::<b>{{context.methodName}}</b></span></span>
                    </template>
                    <b-form v-on:submit.prevent="">
                        <div>
                            <b-input-group class="mt-3">
                                <b-form-input type="search" placeholder="Filter" id="element-filter-input-field" @input="updateElementFilterValue" class="mr-sm-6" aria-describedby="element-filter-help-block"></b-form-input>
                            </b-input-group>
                            <b-form-checkbox v-model="currentElementSelectedOnly" name="check-button" switch>
                                  Show only selected items
                            </b-form-checkbox>
                        </div>
                        <b-form-text id="element-filter-help-block">
                            Filter elements.
                        </b-form-text>
                    </b-form>
                    <b-tabs align="left" card @input="handleTabIndex">
                        <!-- This tabs content will not be mounted until the tab is shown -->
                        <!-- and will be un-mounted when hidden -->
                        <b-tab :title="'Funcs (' + len(filteredFuncs) + ')'" active>
                            <b-list-group>
                                <cm-func-item
                                  v-for="item in filteredFuncs"
                                  v-bind:key="item.ID"
                                  v-bind:item="item"
                                  v-bind:func="item.Func || item"
                                  v-bind:isflow="context.isFlow"
                                ></cm-func-item>
                            </b-list-group>
                        </b-tab>
                        <b-tab :title="'Methods (' + len(filteredTypeMethods) + ')'">
                            <b-list-group>
                                <cm-func-item
                                  v-for="item in filteredTypeMethods"
                                  v-bind:key="item.ID"
                                  v-bind:item="item"
                                  v-bind:func="item.Func || item"
                                  v-bind:isflow="context.isFlow"
                                ></cm-func-item>
                            </b-list-group>
                        </b-tab>
                        <b-tab :title="'Interfaces (' + len(filteredInterfaceMethods) + ')'">
                            <b-list-group>
                                <cm-func-item
                                  v-for="item in filteredInterfaceMethods"
                                  v-bind:key="item.ID"
                                  v-bind:item="item"
                                  v-bind:func="item.Func || item"
                                  v-bind:isflow="context.isFlow"
                                ></cm-func-item>
                            </b-list-group>
                        </b-tab>
                        <b-tab :title="'Structs (' + len(filteredStructs) + ')'" v-if="!context.isFlow">
                            <b-list-group class="text-monospace float-left text-truncate">
                                <cm-struct-item
                                  v-for="item in filteredStructs"
                                  v-bind:key="item.ID"
                                  v-bind:item="item"
                                ></cm-struct-item>
                            </b-list-group>
                        </b-tab>
                        <b-tab :title="'Types (' + len(filteredTypes) + ')'" v-if="!context.isFlow">
                            <b-list-group class="text-monospace float-left text-truncate">
                                <cm-type-item
                                  v-for="item in filteredTypes"
                                  v-bind:key="item.ID"
                                  v-bind:item="item"
                                ></cm-struct-item>
                            </b-list-group>
                        </b-tab>
                    </b-tabs>
                    <template #modal-footer>
                        <div class="w-100">
                            <b-button variant="secondary" class="float-right" size="sm" @click="$bvModal.hide('modal-show-code')">
                                Close
                            </b-button>
                        </div>
                    </template>
                </b-modal>
            </template>
        </b-container>
    </div>
    <script>
    function cc(...elems) {
        return elems.join("-")
    }

    function len(elem) {
        if (elem == null) { return 0 }
        return elem.length
    }

    function marshal(obj) {
        return JSON.stringify(obj)
    }

    function revf(path, version) {
        return path + "@" + version
    }

    function newEdge(parentID, id) {
        let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("id", id);
        let parentNode = document.getElementById(parentID);
        if (parentNode == null) {
            console.log(parentID, "does not exist");
            return
        }
        parentNode.appendChild(path)
    }

    function remChildren(parentID) {
        const parentNode = document.getElementById(parentID);
        if (parentNode == null) {
            console.log(parentID, "does not exist");
            return
        }
        while (parentNode.lastElementChild) {
            parentNode.removeChild(parentNode.lastElementChild);
        }
    }

    function drawAnArrow(idFrom, idInto, idArrowLeft, idArrowRight) {
        console.log(idFrom, idInto, idArrowLeft, idArrowRight);

        if (idFrom == "" || idInto == "") {
            return
        }
        var divFrom = document.getElementById(idFrom);
        var divInto = document.getElementById(idInto);
        var arrowLeft = document.getElementById(idArrowLeft);
        var arrowRight = document.getElementById(idArrowRight);

        if (divFrom == null || divInto == null) {
            return
        }
        if (divFrom.offsetParent == null || divInto.offsetParent == null) {
            return
        }
        let rectFrom = divFrom.getBoundingClientRect();
        let rectInto = divInto.getBoundingClientRect();

        var drawConnector = function() {
            var posnALeft = {
                x: divFrom.offsetLeft - 8,
                y: divFrom.offsetTop + divFrom.offsetHeight / 2
            };
            var posnBLeft = {
                x: divInto.offsetLeft - 8,
                y: divInto.offsetTop + divInto.offsetHeight / 2
            };

            console.log(posnALeft);
            console.log(posnBLeft);

            var posnFrom = {
                x: rectFrom.right - rectFrom.width / 2,
                y: rectFrom.bottom - rectFrom.height
            };
            var posnInto = {
                x: rectInto.right - rectInto.width / 2,
                y: rectInto.bottom - rectInto.height
            };
            console.log(posnFrom);
            console.log(posnInto);

            let horizOffset = 0;
            if (divInto.offsetLeft > divFrom.offsetLeft) {
                horizOffset = divInto.offsetLeft - divFrom.offsetLeft
            } else {
                horizOffset = divFrom.offsetLeft - divInto.offsetLeft
            }

            horizOffset = horizOffset + rectFrom.width + rectInto.width

            var dStrLeft =
                "M" +
                (divFrom.offsetLeft + rectFrom.width / 2) + "," + (divInto.offsetParent.offsetHeight + 7) + " " +
                "C " +
                (posnALeft.x + rectInto.width / 2) + "," + (divInto.offsetParent.offsetHeight + 7) + " " +
                (Math.abs(horizOffset)) + "," + (divFrom.offsetParent.offsetHeight - 60) + " " +
                (divInto.offsetLeft + rectInto.width / 2) + "," + (divInto.offsetParent.offsetHeight) + " "
            arrowLeft.setAttribute("d", dStrLeft);
        };

        drawConnector();
    }

    window.app = new Vue({
        el: '#codemill-app',
        data: {
            context: {
              modelName: "",
              methodName: "",
              isFlow: false
            },
            tabIndex: 0,
            sourceModalIsShown: false,
            cacheModules: [],
            modelKinds: [],
            newModel: {
              kind: "",
              name: "",
              show: false
            },
            xspec: {},
            currentPackage: {
                source: {},
                path: "",
                version: ""
            },
            searchData: {
                results: [],
                current: "",
                currentOut: ""
            },
            isBusy: {
                search: false,
                loadCode: false,
                cacheModules: false,
                xspec: true
            },
            currentElementFilter: "",
            currentElementSelectedOnly: false,
        },
        created() {
            this.spec_Load();
            this.spec_LoadModelKinds();

            // this.doSearch("revel");
        },
        updated() {
            this.drawFlowArrowsBySpec();
        },
        mounted() {
          this.$root.$on('bv::modal::shown', (bvEvent, modalId) => {
            if (this.$data.context.isFlow == true && modalId == "modal-show-code") {
              this.$data.sourceModalIsShown = true;

              let tabIndex = this.$data.tabIndex;
              if (tabIndex == 0) {
                this.drawAllArrowsForFuncs();
              }
              if (tabIndex == 1) {
                this.drawAllArrowsForTypeMethods();
              }
              if (tabIndex == 2) {
                this.drawAllArrowsForInterfaceMethods();
              }
            }
          });
          this.$root.$on('bv::modal::hidden', (bvEvent, modalId) => {
            if (modalId == "modal-show-code") {
              this.$data.sourceModalIsShown = false;
            }
          })
        },
        computed: {
            filteredFuncs() {
                if (!this.$data.currentPackage.source.Funcs) {
                    return
                }
                let [path, version, modelName, methodName, selOnly] = this.getFilterCtx();

                const isTrue = (element) => element == true;
                const isTrueFlows = (block) => block.Inp.some(isTrue) || block.Out.some(isTrue);
 
                return this.$data.currentPackage.source.Funcs.filter(item => {
                  if (selOnly) {
                    let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, item.ID);
                    return qualifier && ((qualifier.Pos && qualifier.Pos.some(isTrue)) || (qualifier.Flows && qualifier.Flows.Blocks.some(isTrueFlows)))
                  }
                  return true
                }).filter(item => {
                    let matches = this.elementFilterMatches(item.Signature) || this.docsOrCommentsMatch(item);
                    return matches
                });
            },
            filteredTypeMethods() {
                if (!this.$data.currentPackage.source.TypeMethods) {
                    return
                }
                let [path, version, modelName, methodName, selOnly] = this.getFilterCtx();

                const isTrue = (element) => element == true;
                const isTrueFlows = (block) => block.Inp.some(isTrue) || block.Out.some(isTrue);

                return this.$data.currentPackage.source.TypeMethods.filter(item => {
                  if (selOnly) {
                    let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, item.ID);
                    return qualifier && ((qualifier.Pos && qualifier.Pos.some(isTrue)) || (qualifier.Flows && qualifier.Flows.Blocks.some(isTrueFlows)))
                  }
                  return true
                }).filter(item => {
                    let matches = this.elementFilterMatches(item.Func.Signature) || this.docsOrCommentsMatch(item);
                    return matches
                });
            },
            filteredInterfaceMethods() {
                if (!this.$data.currentPackage.source.InterfaceMethods) {
                    return
                }
                let [path, version, modelName, methodName, selOnly] = this.getFilterCtx();

                const isTrue = (element) => element == true;
                const isTrueFlows = (block) => block.Inp.some(isTrue) || block.Out.some(isTrue);

                return this.$data.currentPackage.source.InterfaceMethods.filter(item => {
                  if (selOnly) {
                    let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, item.ID);
                    return qualifier && ((qualifier.Pos && qualifier.Pos.some(isTrue)) || (qualifier.Flows && qualifier.Flows.Blocks.some(isTrueFlows)))
                  }
                  return true
                }).filter(item => {
                    let matches = this.elementFilterMatches(item.Func.Signature) || this.docsOrCommentsMatch(item);
                    return matches
                });
            },
            filteredStructs() {
                if (!this.$data.currentPackage.source.Structs) {
                    return
                }

                let [path, version, modelName, methodName, selOnly] = this.getFilterCtx();

                return this.$data.currentPackage.source.Structs.filter(item => {
                  if (selOnly) {
                    let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, item.ID);
                    const hasAnySelectedField = (field) => field.VarName in qualifier.Fields;
                    return qualifier && item.Fields.some(hasAnySelectedField)
                  }
                  return true
                }).filter(item => {
                    // TODO: search also in KindString?
                    let matches = this.elementFilterMatches(item.TypeName) || item.Fields.some(this.structFieldMatches) || this.docsOrCommentsMatch(item) || item.Fields.some(this.docsOrCommentsMatch);
                    return matches
                });
            },
            filteredTypes() {
                if (!this.$data.currentPackage.source.Types) {
                    return
                }

                let [path, version, modelName, methodName, selOnly] = this.getFilterCtx();

                return this.$data.currentPackage.source.Types.filter(item => {
                  if (selOnly) {
                    let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, item.ID);
                    return qualifier && qualifier.Value
                  }
                  return true
                }).filter(item => {
                    let matches = this.elementFilterMatches(item.TypeName) || this.elementFilterMatches(item.KindString) || this.docsOrCommentsMatch(item);
                    return matches
                });
            },
        },
        methods: {
            cc: cc,
            len: len,
            marshal: marshal,
            revf: revf,
            fmtv(version) {
              // Format version:
              return version!="local"?"@"+version:""
            },
            getFilterCtx(){
              let path = this.$data.currentPackage.path;
              let version = this.$data.currentPackage.version;
              let modelName = this.$data.context.modelName;
              let methodName = this.$data.context.methodName;
              let selOnly = this.$data.currentElementSelectedOnly;

              return [path, version, modelName, methodName, selOnly]
            },
            makeToast(variant = null, title, body) {
                this.$bvToast.toast(
                    body, {
                        title: title,
                        variant: variant,
                        solid: true
                    })
            },
            search() {
                this.searchData.currentOut = this.searchData.current.trim();
                this.doSearch(this.searchData.currentOut);
            },
            updateElementFilterValue(val) {
                this.currentElementFilter = val;
            },
            elementFilterMatches(ident) {
                if (!this.currentElementFilter || this.currentElementFilter.trim() == "") {
                    return true
                }
                this.currentElementFilter = this.currentElementFilter.toLowerCase().trim();
                return ident.toLowerCase().includes(this.currentElementFilter);
            },
            structFieldMatches(field) {
                return this.elementFilterMatches(field.VarName) || this.elementFilterMatches(field.TypeString)
            },
            docsOrCommentsMatch(item) {
                return (item.Docs && item.Docs.some(this.elementFilterMatches)) || (item.Comments && item.Comments.some(this.elementFilterMatches))
            },
            listVersions(searchItem) {
                console.log("Loading list of versions...");
                console.log(searchItem);
                let url = '/api/versions?path=' + searchItem.path;

                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        searchItem.versions = json.results;
                        searchItem.gotVersions = true;
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            loadCachedVersionList() {
                console.log("Getting list of cached versions...");
                let url = '/api/cached';

                this.$data.isBusy.cacheModules = true;
                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$data.cacheModules = json.results;
                        this.$data.isBusy.cacheModules = false;
                    })
                    .catch((error) => {
                        this.$data.isBusy.cacheModules = false;
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            loadCode(path, version) {
                console.log("Loading code...selected:", this.revf(path, version));
                this.$data.isBusy.loadCode = true;
                this.$data.currentPackage.path = path;
                this.$data.currentPackage.version = version;

                let url = '/api/source?path=' + path + "&v=" + version;

                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {

                        // Sync source with spec:
                        json.Funcs.forEach((item) => {
                          if (this.$data.context.isFlow == false) {
                            this.PosSyncParametersWithSpec(item);
                            this.PosSyncResultsWithSpec(item);
                          } else {
                            this.FlowSyncFuncWithSpec(item);
                          }
                        });
                        json.TypeMethods.forEach((item) => {
                          if (this.$data.context.isFlow == false) {
                            this.PosSyncReceiverWithSpec(item);
                            this.PosSyncParametersWithSpec(item);
                            this.PosSyncResultsWithSpec(item);
                          } else {
                            this.FlowSyncFuncWithSpec(item);
                          }
                        });
                        json.InterfaceMethods.forEach((item) => {
                          if (this.$data.context.isFlow == false) {
                            this.PosSyncReceiverWithSpec(item);
                            this.PosSyncParametersWithSpec(item);
                            this.PosSyncResultsWithSpec(item);
                          } else {
                            this.FlowSyncFuncWithSpec(item);
                          }
                        });
                        json.Structs.forEach((item) => {
                          this.syncFieldsWithSpec(item);
                        });
                        json.Types.forEach((item) => {
                          item.Checked = this.getTypeValueFromSpec(item.ID);
                        });
                        
                        this.$data.currentPackage.source = json;
                        this.$data.isBusy.loadCode = false;
                        this.$data.currentElementFilter = "";
                        this.$data.currentElementSelectedOnly = false;
                        this.$bvModal.show('modal-show-code');


                        if (json.Module) {
                            // TODO: if the version is different from what was requested,
                            // then mark it some way.
                            this.$data.currentPackage.version = json.Module.Version;
                        }
                    })
                    .catch((error) => {
                        this.$data.isBusy.loadCode = false;
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            setContext(xmodelName, xmethodName, isFlow) {
              // Set current context:
              this.$data.context.modelName = xmodelName;
              this.$data.context.methodName = xmethodName;
              this.$data.context.isFlow = isFlow;
            },
            openSearchView(xmodel, xmethod) {
              console.log(xmodel, xmethod);
              
              // TODO: if other model kinds need flow, add them here:
              let isFlow = xmodel.Kind == 'TaintTracking';

              this.setContext(xmodel.Name, xmethod.Name, isFlow);

              // Open the modal that list packages (search/recent):
              this.$bvModal.show('modal-list-remote-packages');
            },
            doSearch(searchText) {
                this.isBusy.search = true;
                let url = '/api/search?q=' + searchText;

                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.isBusy.search = false;

                        let gotResults = [];

                        if (json.results == null) {
                            this.searchData.results = [];
                        } else {
                            json.results.forEach(function(item, itemIndex) {
                                item.versions = [];
                                item.gotVersions = false;
                                gotResults.push(item);
                            });
                            this.searchData.results = gotResults;
                        }
                    })
                    .catch((error) => {
                        this.isBusy.search = false;
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            spec_LoadModelKinds() {
                console.log("Loading list of available model kinds...");
                let url = '/api/models/kinds';

                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        let res = [{ text: 'Choose kind...', value: '' }].concat(json.results)
                        this.$data.modelKinds = res;
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            spec_Load() {
                console.log("Loading spec...");
                let url = '/api/spec';
                this.$data.isBusy.xspec = true;

                fetch(url)
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$data.xspec = json;
                        this.$data.isBusy.xspec = false;
                    })
                    .catch((error) => {
                        this.$data.isBusy.xspec = false;
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            spec_VerifyPushModel() {
              if (this.newModel.kind == "") {
                this.makeToast("danger", "Error", "No kind specified for new model");
                return
              }
              if (this.newModel.name == "") {
                this.makeToast("danger", "Error", "No name specified for new model");
                return
              }

              this.spec_PushModel(this.newModel.name,this.newModel.kind)
            },
            spec_PushModel(name, kind) {
                console.log("Adding model to spec ...", name);
                let url = '/api/spec/models';

                let payload = {
                    "Name": name,
                    "Kind": kind
                }
                console.log(payload);

                fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$data.xspec = json;

                        this.$data.newModel.kind = "";
                        this.$data.newModel.name = "";
                        this.$data.newModel.show = false;
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            findModel(name) {

              var found = this.$data.xspec.Models.filter(function (mdl) {
                return mdl.Name == name;
              });

              if (len(found) == 0) {
                return null
              }

              return found[0]
            },
            findMethod(methods, name) {
              var found = methods.filter(function (mdl) {
                return mdl.Name == name;
              });

              if (len(found) == 0) {
                return null
              }

              return found[0]
            },
            findSelector(selectors,path, version, id) {
              var found = selectors.filter(function (sl) {
                return sl.Qualifier.Path == path && sl.Qualifier.Version == version && sl.Qualifier.ID == id;
              });

              if (len(found) == 0) {
                return null
              }

              return found[0]
            },
            getQualifierFromSpec(path, version, modelName, methodName, id) {
              // console.log("Getting func component checkbox value")
              let model = this.findModel(modelName);
              // console.log("model", model);
              if (model == null) {
                return null
              }
              let method = this.findMethod(model.Methods, methodName);
              // console.log("method", method);
              if (method == null) {
                return null
              }
              let selector = this.findSelector(method.Selectors, path, version, id);
              // console.log("selector", selector);
              if (selector == null) {
                return null
              }

              if (selector.Qualifier) {
                return selector.Qualifier
              }
              return null
            },
            getFuncPosValueAtIndexFromSpec(index, funcID) {
              // console.log("Getting func component checkbox value")

              let path = this.$data.currentPackage.path;
              let version = this.$data.currentPackage.version;
              let modelName = this.$data.context.modelName;
              let methodName = this.$data.context.methodName;

              let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, funcID);
              if (qualifier == null) {
                return false
              }

              if (qualifier.Pos && qualifier.Pos[index]) {
                return qualifier.Pos[index]
              }
              return false
            },
            getFuncFlowsFromSpec(funcID) {
              // console.log("Getting func component checkbox value")

              let path = this.$data.currentPackage.path;
              let version = this.$data.currentPackage.version;
              let modelName = this.$data.context.modelName;
              let methodName = this.$data.context.methodName;

              let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, funcID);
              if (qualifier == null) {
                return null
              }

              if (qualifier.Flows != null) {
                return qualifier.Flows
              }
              return null
            },
            getTypeValueFromSpec(typeID) {
              // console.log("Getting type checkbox value")

              let path = this.$data.currentPackage.path;
              let version = this.$data.currentPackage.version;
              let modelName = this.$data.context.modelName;
              let methodName = this.$data.context.methodName;

              let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, typeID);
              if (qualifier == null) {
                return false
              }

              return qualifier.Value
            },
            getStructFieldValueFromSpec(struct, field) {
              // console.log("Getting struct field checkbox value")
              // console.log(struct, field)

              let path = this.$data.currentPackage.path;
              let version = this.$data.currentPackage.version;
              let modelName = this.$data.context.modelName;
              let methodName = this.$data.context.methodName;

              let qualifier = this.getQualifierFromSpec(path, version, modelName, methodName, struct.ID);
              if (qualifier == null) {
                return false
              }

              return qualifier.Fields && field.VarName in qualifier.Fields

              // - find model
              // - find method
              // - find selector (Kind=Struct)
              // - matches Qualifier
              // - if .Fields[fieldVar] exists, then use the value.
            },
            PosSyncReceiverWithSpec(item) {
              if (!item.Receiver) {
                return
              }
              item.Receiver.Checked = this.getFuncPosValueAtIndexFromSpec(0, item.ID);
            },
            PosSyncParametersWithSpec(item) {
              let fItem = item.Func || item;
              if (!fItem || !fItem.Parameters) {
                return
              }
              let receiverLen = item.Receiver?1:0;
              var params = fItem.Parameters;
              params.forEach((param, paramIndex) => {
                  param.Checked = this.getFuncPosValueAtIndexFromSpec(receiverLen + paramIndex, item.ID);
              });
            },
            PosSyncResultsWithSpec(item) {
              let fItem = item.Func || item;
              if (!fItem || !fItem.Results) {
                return
              }
              let receiverLen = item.Receiver?1:0;
              let paramsLen = this.len(fItem.Parameters);
              var results = fItem.Results;
              results.forEach((res, resIndex) => {
                  res.Checked = this.getFuncPosValueAtIndexFromSpec(receiverLen + paramsLen + resIndex, item.ID);
              });
            },
            newBoolArray(len) {
                return new Array(len).fill(false);
            },
            FlowSyncFuncWithSpec(item) {
              let receiverLen = item.Receiver?1:0;
              let fItem = item.Func || item;
              let paramsLen = this.len(fItem.Parameters);
              let resultsLen = this.len(fItem.Results);

              let width = receiverLen + paramsLen + resultsLen;

              let flows = this.getFuncFlowsFromSpec(item.ID);
              if (flows == null) {
                item.Flows = {
                  Blocks: [{Inp: this.newBoolArray(width), Out: this.newBoolArray(width) }]
                };
              } else {
                item.Flows = flows;
              }
            },
            syncFieldsWithSpec(item) {
              item.Fields.forEach((field) => {
                  field.Checked = this.getStructFieldValueFromSpec(item, field);
              });
            },
            drawArrowsFor: function(blockIndex, fn) {
                // Remove any existing arrows:
                let parentID = cc(fn.ID, "block", blockIndex, 'arrows');
                remChildren(parentID);

                let block = fn.Flows.Blocks[blockIndex];
                block.Inp.forEach(function(itemInp, indexInp) {

                    block.Out.forEach(function(itemOutp, indexOutp) {
                        if (!itemInp || !itemOutp) {
                            return
                        }
                        console.log(itemOutp, indexOutp);
                        console.log(itemInp, indexInp);

                        let leftArrowID = cc(fn.ID, "block", blockIndex, "arrow", "left", "from", indexInp, "to", indexOutp);
                        let rigthArrowID = cc(fn.ID, "block", blockIndex, "arrow", "right", "from", indexInp, "to", indexOutp);
                        newEdge(parentID, leftArrowID);
                        newEdge(parentID, rigthArrowID);

                        let idFrom = cc(fn.ID, "block", blockIndex, "bl", indexInp)
                        let idInto = cc(fn.ID, "block", blockIndex, "bl", indexOutp)

                        drawAnArrow(idFrom, idInto, leftArrowID, rigthArrowID);

                    });
                });
            },
            drawAllArrowsForFuncs: function() {
                // Draw arrows:
                let self = this;
                this.$root.$data.currentPackage.source.Funcs.forEach(function(element, elementIndex) {
                  if (element.Flows !== null) {
                    element.Flows.Blocks.forEach(function(block, blockIndex) {
                        self.drawArrowsFor(blockIndex, element)
                    });
                  }
                });
            },
            drawAllArrowsForTypeMethods: function() {
                // Draw arrows:
                let self = this;
                this.$root.$data.currentPackage.source.TypeMethods.forEach(function(element, elementIndex) {
                  if (element.Flows !== null) {
                    element.Flows.Blocks.forEach(function(block, blockIndex) {
                        self.drawArrowsFor(blockIndex, element)
                    });
                  }
                });
            },
            drawAllArrowsForInterfaceMethods: function() {
                // Draw arrows:
                let self = this;
                this.$root.$data.currentPackage.source.InterfaceMethods.forEach(function(element, elementIndex) {
                  if (element.Flows !== null) {
                    element.Flows.Blocks.forEach(function(block, blockIndex) {
                        self.drawArrowsFor(blockIndex, element)
                    });
                  }
                });
            },
            handleTabIndex: function(tabIndex){
              this.$data.tabIndex = tabIndex;

              setTimeout(() => {
                if (this.$data.sourceModalIsShown == true) {
                  if (tabIndex == 0) {
                    this.drawAllArrowsForFuncs();
                  }
                  if (tabIndex == 1) {
                    this.drawAllArrowsForTypeMethods();
                  }
                  if (tabIndex == 2) {
                    this.drawAllArrowsForInterfaceMethods();
                  }
                }
               }, 500);

            },
            sleep: function(ms) {
              return new Promise(resolve => setTimeout(resolve, ms));
            },
            drawArrowsForSpec: function(blockIndex, fn) {
                // Remove any existing arrows:
                let parentID = cc(fn.ID+'_flow', "block", blockIndex, 'arrows');
                remChildren(parentID);

                let block = fn.Flows.Blocks[blockIndex];
                block.Inp.forEach((itemInp, indexInp) => {

                    block.Out.forEach((itemOutp, indexOutp) => {
                        if (!itemInp || !itemOutp) {
                            return
                        }
                        console.log(itemOutp, indexOutp);
                        console.log(itemInp, indexInp);

                        let leftArrowID = cc(fn.ID+'_flow', "block", blockIndex, "arrow", "left", "from", indexInp, "to", indexOutp);
                        let rigthArrowID = cc(fn.ID+'_flow', "block", blockIndex, "arrow", "right", "from", indexInp, "to", indexOutp);
                        newEdge(parentID, leftArrowID);
                        newEdge(parentID, rigthArrowID);

                        let idFrom = cc(fn.ID+'_flow', "block", blockIndex, "bl", indexInp)
                        let idInto = cc(fn.ID+'_flow', "block", blockIndex, "bl", indexOutp)
                        let idSvg = cc("svg", fn.ID+'_flow', "block", blockIndex)

                        this.drawArrowSpecStyle(idFrom, idInto, leftArrowID, rigthArrowID, idSvg);

                    });
                });
            },
            drawArrowSpecStyle: function(idFrom, idInto, idArrowLeft, idArrowRight, svgID) {
                console.log(idFrom, idInto, idArrowLeft, idArrowRight);

                if (idFrom == "" || idInto == "") {
                    return
                }
                var svgElem = document.getElementById(svgID);
                var divFrom = document.getElementById(idFrom);
                var divInto = document.getElementById(idInto);
                var arrowLeft = document.getElementById(idArrowLeft);
                var arrowRight = document.getElementById(idArrowRight);

                if (divFrom == null || divInto == null) {
                    return
                }
                if (divFrom.offsetParent == null || divInto.offsetParent == null) {
                    return
                }
                let rectFrom = divFrom.getBoundingClientRect();
                let rectInto = divInto.getBoundingClientRect();
                let rectSvg = svgElem.getBoundingClientRect();

                var drawConnector = function() {
                    let anchorPoint1 = {
                      x: (rectFrom.x - rectSvg.x + (rectFrom.width / 2)),
                      y: (divFrom.offsetParent.offsetHeight - (rectFrom.height*3))
                    }

                    let anchorPoint2 = {
                      x: (rectInto.x - rectSvg.x + (rectInto.width / 2)),
                      y: (divInto.offsetParent.offsetHeight - (rectFrom.height*3.3))
                    }

                    let curveHeight = 80;

                    let controlPoint1 = {
                      x: anchorPoint1.x,
                      y: anchorPoint1.y - curveHeight
                    }

                    let controlPoint2 = {
                      x: anchorPoint2.x,
                      y: anchorPoint2.y - curveHeight
                    }

                    let dStrLeft = `M ${anchorPoint1.x},${anchorPoint1.y} C ${controlPoint1.x},${controlPoint1.y} ${controlPoint2.x},${controlPoint2.y} ${anchorPoint2.x},${anchorPoint2.y}`
                    arrowLeft.setAttribute("d", dStrLeft);
                };

                drawConnector();
            },
            drawFlowArrowsBySpec: function() {
                // Draw arrows:
                let self = this;
                this.$root.$data.xspec.Models.forEach(model => {
                  model.Methods.forEach(method => {
                    method.Selectors.forEach(selector => {
                      if (selector.Kind == "Func" && selector.Qualifier.Flows !== null) {
                        selector.Qualifier.Flows.Blocks.forEach((block, blockIndex) => {
                          this.drawArrowsForSpec(blockIndex, selector.Qualifier);
                        });
                      }
                    });
                  });
                });
            },
        }
    });
    </script>

    <script type="text/javascript">
    Vue.component('cm-xmodel', {
        methods: {
            cc: cc,
            len: len,
        },
        props: ['xmodel'],
        template: "#cm-xmodel-template"
    });
    </script>
    <script type="text/x-template" id="cm-xmodel-template">
        <div class="xmodel">
          <div>model <b class="text-large">{{xmodel.Name}}</b> of kind <i class="text-large">{{xmodel.Kind}}</i> {</div>
            <cm-xmethod v-for="(item, key) in xmodel.Methods" v-bind:key="key" v-bind:xmethod="item" v-bind:xmodel="xmodel" class="ml-2"></cm-xmethod>
          <div>}</div>
        </div>
    </script>

    <script type="text/javascript">
    Vue.component('cm-xmethod', {
        methods: {
            cc: cc,
            len: len,
            openSearchView: function(xmodel, xmethod) {
              this.$root.openSearchView(xmodel, xmethod);
            }
        },
        props: ['xmethod', 'xmodel'],
        template: "#cm-xmethod-template"
    });
    </script>
    <script type="text/x-template" id="cm-xmethod-template">
        <div class="xmethod" v-bind:class="{ 'error-no-selectors': len(xmethod.Selectors) == 0 }" :title="len(xmethod.Selectors) == 0 ? 'Error: No selectors specified':''">
          <div>method <b class="text-large">{{xmethod.Name}}()</b> (len = {{len(xmethod.Selectors)}} selectors) {</div>
            <cm-xselector
              v-for="(item, key) in xmethod.Selectors"
              v-bind:key="key"
              v-bind:xselector="item"
              v-bind:xmodelName="xmodel.Name"
              v-bind:xmethodName="xmethod.Name"
              class="ml-2"
              ></cm-xselector>

            <!-- Modal for searching packages -->
            <template>
                <b-button @click="openSearchView(xmodel, xmethod)" size="sm" variant="outline-primary" class="ml-2 mt-1"><b-icon icon="plus-square"></b-icon> Add a selector</b-button>
            </template>

          <div>}</div>
        </div>
    </script>

    <script type="text/javascript">
    Vue.component('cm-xselector', {
        methods: {
            cc: cc,
            len: len,
            loadCode: function(path, version) {
                this.$root.loadCode(path, version);
            },
            fmtv: function(version) {
              return this.$root.fmtv(version);
            },
            setContext(xmodelName, xmethodName, isFlow) {
                this.$root.setContext(xmodelName, xmethodName, isFlow);
            }
        },
        props: ['xselector', 'xmodelName', 'xmethodName'],
        template: "#cm-xselector-template"
    });
    </script>
    <script type="text/x-template" id="cm-xselector-template">
        <div class="xselector">
          <div
            class="package-indication"
            @click="setContext(xmodelName, xmethodName, xselector.Qualifier.Flows !== null); loadCode(xselector.Qualifier.Path,xselector.Qualifier.Version)"
            title="Click to open source view"
          >{{xselector.Qualifier.Path}}{{fmtv(xselector.Qualifier.Version)}}</div>
          <div v-if="xselector.Kind == 'Struct'">
            <div>struct <b>{{xselector.Qualifier.TypeName}}</b> {</div>
            <div v-for="(field, fieldIndex) in xselector.Qualifier.Fields" v-bind:key="field.Name" class="ml-2">
              <span :title="field.KindString" class="hover-field">{{field.Name}} <b>{{field.TypeString}}</b></span>
            </div>
            <div class="ml-2 text-muted" v-if="xselector.Qualifier.Left">// Has {{xselector.Qualifier.Left}} other ignored fields</div>
            <div>}</div>
          </div>

          <!-- Func with Pos -->
          <div v-if="xselector.Kind == 'Func' && xselector.Qualifier.Pos !== null">
            <div class="text-monospace d-inline">func</div>
            
            <div
              v-if="xselector.Qualifier.Elements.Receiver"
              :title="xselector.Qualifier.Elements.Receiver.KindString"
              v-bind:class="{ 'selected-warning': xselector.Qualifier.Pos[xselector.Qualifier.Elements.Receiver.AI] }"
              class="text-monospace d-inline"
              >({{xselector.Qualifier.Elements.Receiver.TypeString}})</div>

            <div class="text-monospace d-inline" v-if="len(xselector.Qualifier.Elements.Parameters) == 0"><b>{{xselector.Qualifier.Name}}</b>()</div>

            <div
              v-for="(elem, elemIndex) in xselector.Qualifier.Elements.Parameters"
              v-bind:key="elem.TypeString + 'param' + elemIndex"
              class="text-monospace d-inline"
              ><span v-if="elemIndex==0"><b>{{xselector.Qualifier.Name}}</b>(</span><span :title="elem.KindString" v-bind:class="{ 'selected-primary': xselector.Qualifier.Pos[elem.AI] }">{{elem.Name?elem.Name+" ":""}}<b>{{elem.TypeString}}</b>{{elemIndex==len(xselector.Qualifier.Elements.Parameters) - 1 ?")":", "}}</span>
            </div>

            <div
              v-for="(elem, elemIndex) in xselector.Qualifier.Elements.Results"
              v-bind:key="elem.TypeString + 'result' + elemIndex"
              class="text-monospace d-inline"
              :title="elem.KindString"
              v-bind:class="{ 'selected-success': xselector.Qualifier.Pos[elem.AI] }"
              >{{elemIndex==0?"(":""}}{{elem.Name?elem.Name+" ":""}}<b>{{elem.TypeString}}</b>{{elemIndex==len(xselector.Qualifier.Elements.Results) - 1 ?")":", "}}</div>
          </div>

          <!-- Func with Flow -->
          <div v-if="xselector.Kind == 'Func' && xselector.Qualifier.Flows !== null">

            <div class="flow-block" v-for="(block, blockIndex) in xselector.Qualifier.Flows.Blocks">
              <div class="flow-block-index-indicator" :title="'Block #' + blockIndex">
                #{{blockIndex}}
              </div>
              <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" :id="cc('svg',xselector.Qualifier.ID+'_flow','block',blockIndex)">
                  <defs>
                      <marker :id="cc('arrowhead',xselector.Qualifier.ID+'_flow','block',blockIndex)" viewBox="0 0 10 10" refX="3" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                          <path d="M 0 0 L 10 5 L 0 10 z" />
                      </marker>
                  </defs>
                  <g fill="none" stroke="black" stroke-width="2" :marker-end="'url(#'+cc('arrowhead',xselector.Qualifier.ID+'_flow','block',blockIndex)+')'" :id="cc(xselector.Qualifier.ID+'_flow','block',blockIndex,'arrows')">
                  </g>
              </svg>
              <div class="text-monospace d-inline">func</div>
              
              <div
                v-if="xselector.Qualifier.Elements.Receiver"
                :title="xselector.Qualifier.Elements.Receiver.KindString"
                v-bind:class="{ 
                  'selected-primary': xselector.Qualifier.Flows && xselector.Qualifier.Flows.Blocks[blockIndex].Inp[0],
                  'selected-warning': xselector.Qualifier.Flows && xselector.Qualifier.Flows.Blocks[blockIndex].Out[0],
                }"
                :id="cc(xselector.Qualifier.ID+'_flow','block',blockIndex,'bl', 0)"
                class="text-monospace d-inline"
                >({{xselector.Qualifier.Elements.Receiver.TypeString}})</div>

              <div class="text-monospace d-inline" v-if="len(xselector.Qualifier.Elements.Parameters) == 0"><b>{{xselector.Qualifier.Name}}</b>()</div>

              <div
                v-for="(elem, elemIndex) in xselector.Qualifier.Elements.Parameters"
                v-bind:key="elem.TypeString + 'param' + elemIndex"
                class="text-monospace d-inline"
                ><span v-if="elemIndex==0"><b>{{xselector.Qualifier.Name}}</b>(</span><span
                  :title="elem.KindString"
                  :id="cc(xselector.Qualifier.ID+'_flow','block',blockIndex,'bl', xselector.Qualifier.Elements.Receiver?1+elemIndex:elemIndex)"
                  v-bind:class="{
                     'selected-primary': xselector.Qualifier.Flows && (xselector.Qualifier.Flows.Blocks[blockIndex].Inp[ xselector.Qualifier.Elements.Receiver?1+elemIndex:elemIndex ]),
                     'selected-warning': xselector.Qualifier.Flows && (xselector.Qualifier.Flows.Blocks[blockIndex].Out[ xselector.Qualifier.Elements.Receiver?1+elemIndex:elemIndex ]) 
                  }"
                  >{{elem.Name?elem.Name+" ":""}}<b>{{elem.TypeString}}</b>{{elemIndex==len(xselector.Qualifier.Elements.Parameters) - 1 ?")":", "}}</span>
              </div>

              <div
                v-for="(elem, elemIndex) in xselector.Qualifier.Elements.Results"
                v-bind:key="elem.TypeString + 'result' + elemIndex"
                class="text-monospace d-inline"
                :title="elem.KindString"
                :id="cc(xselector.Qualifier.ID+'_flow','block',blockIndex,'bl', xselector.Qualifier.Elements.Receiver?1+len(xselector.Qualifier.Elements.Parameters)+elemIndex:len(xselector.Qualifier.Elements.Parameters)+elemIndex)"
                v-bind:class="{
                  'selected-primary': xselector.Qualifier.Flows && (xselector.Qualifier.Flows.Blocks[blockIndex].Inp[ xselector.Qualifier.Elements.Receiver?1+len(xselector.Qualifier.Elements.Parameters)+elemIndex:len(xselector.Qualifier.Elements.Parameters)+elemIndex ]),
                  'selected-warning': xselector.Qualifier.Flows && (xselector.Qualifier.Flows.Blocks[blockIndex].Out[ xselector.Qualifier.Elements.Receiver?1+len(xselector.Qualifier.Elements.Parameters)+elemIndex:len(xselector.Qualifier.Elements.Parameters)+elemIndex ]),
                 }"
                >{{elemIndex==0?"(":""}}{{elem.Name?elem.Name+" ":""}}<b>{{elem.TypeString}}</b>{{elemIndex==len(xselector.Qualifier.Elements.Results) - 1 ?")":", "}}</div>
            </div>
          </div>

          <div v-if="xselector.Kind == 'Type'">
            <div 
              class="text-monospace d-inline"
              >type <b v-bind:class="{ 'selected-primary': xselector.Qualifier.Value }">{{xselector.Qualifier.TypeName}}</b>, which is {{xselector.Qualifier.KindString}}</div>
          </div>
        </div>
    </script>

    <script type="text/javascript">
    Vue.component('cm-cached-module', {
        methods: {
            cc: cc,
            len: len,
            loadCode: function(path, version) {
                this.$root.loadCode(path, version);
            },
            fmtv: function(version) {
              return this.$root.fmtv(version);
            }
        },
        props: ['cached'],
        template: "#cm-cached-module-template"
    });
    </script>
    <script type="text/x-template" id="cm-cached-module-template">
        <b-list-group-item v-bind:key="cached.Path + cached.Version">
          <b-button variant="success" size="sm" @click="loadCode(cached.Path,cached.Version)">Open</b-button>
          <b class="text-monospace bold">{{cached.Path}}{{fmtv(cached.Version)}}</b>
        </b-list-group-item>
    </script>

    <script type="text/javascript">
    Vue.component('cm-search-result', {
        props: ['item', 'index'],
        template: "#cm-search-result-template",
        methods: {
            loadCode: function(path, version) {
                this.$root.loadCode(path, version);
            },
            listVersions: function(searchItem) {
                this.$root.listVersions(searchItem);
            },
            cc: cc,
            len: len,
            marshal: marshal,
            revf: revf
        }
    });
    </script>
    <script type="text/x-template" id="cm-search-result-template">
        <b-list-group-item :title="item.synopsis" v-bind:key="item.path + index">
          <b-row class="mr-1">
              <b-col align-self="start">
                  <span class="text-monospace float-left d-inline-block text-truncate">
                      <b-icon icon="box-seam" variant="primary"></b-icon> <b>{{item.path}}</b> as "{{item.name}}"
                  </span>
                  <span class="float-right">
                      <span :title="'Imported '+item.import_count+' times'">{{item.import_count}} <b-icon icon="box-arrow-in-down-left" variant="warning"></b-icon></span><span :title="'Starred '+item.stars+' times'" v-if="item.stars"> | {{item.stars}} <b-icon icon="star-fill" variant="warning"></b-icon></span>
                  </span>
              </b-col>
              <b-col align-self="end" lg="1">
                  <b-dropdown text="Select" variant="success" size="sm" @show="listVersions(item)">
                      <b-dropdown-item href="#" v-bind:class="{ hidden: item.gotVersions }" class="text-center align-items-center">
                          <b-spinner type="grow" label="Spinning" align-h="center"></b-spinner>
                      </b-dropdown-item>
                      <b-dropdown-item v-for="version in item.versions" :key="revf(item.path,version)" @click="loadCode(item.path,version)">
                          {{ version }}
                      </b-dropdown-item>
                  </b-dropdown>
              </b-col>
          </b-row>
          <b-row class="mr-1">
              <b-col align-self="start">
                  <small v-bind:class="{ 'text-muted': !item.synopsis }">
                      <b-icon icon="file-text" :variant="item.synopsis ? 'dark':'secondary'"></b-icon> {{item.synopsis}}
                      <b-skeleton animation v-if="!item.synopsis" width="20%" class="d-inline-flex skeleton-na ml-2" title="No description available"></b-skeleton>
                  </small>
              </b-col>
          </b-row>
      </b-list-group-item>
    </script>
    <script type="text/javascript">
    Vue.component('cm-func-item', {
        props: ['item', 'func', 'isflow'],
        template: "#cm-func-item-template",
        computed: {},
        methods: {
            cc: cc,
            len: len,
        }
    });
    </script>
    <script type="text/x-template" id="cm-func-item-template">
        <div>
          <cm-func-item-pos
            v-if="isflow == false"
            v-bind:key="item.ID"
            v-bind:item="item"
            v-bind:func="func"
          ></cm-func-item-pos>

          <cm-func-item-flow
            v-if="isflow == true"
            v-bind:key="item.ID"
            v-bind:item="item"
            v-bind:func="func"
          ></cm-func-item-flow>
        </div>
    </script>

    <script type="text/javascript">
    Vue.component('cm-func-item-pos', {
        props: ['item', 'func'],
        template: "#cm-func-item-pos-template",
        computed: {},
        methods: {
            cc: cc,
            len: len,
            onChangeFuncPos(item, index, value) {
                // - Send the update to the API
                // - Save the response in this.$root.$data.xspec
                // - The UI is bind to this.$root.$data.xspec
                console.log("Modifying func Pos selectors ...");
                
                console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
                console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
                console.log(item.ID, index, value)


                let rPath = this.$root.$data.currentPackage.path;
                let rVersion = this.$root.$data.currentPackage.version;
                let rModel = this.$root.$data.context.modelName;
                let rMethod = this.$root.$data.context.methodName;

                let payload = {
                    "Where": {
                      "Path": rPath,
                      "Version": rVersion,
                      "Model": rModel,
                      "Method": rMethod
                    },
                    "What": {
                      "FuncID": item.ID
                    },
                    "Pos": {
                      "Index": index,
                      "Value": value
                    }
                }
                console.log(payload);

                let url = '/api/spec/funcs';
                fetch(url, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$root.$data.xspec = json;
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.$root.makeToast("danger", "Error", body.error);
                        });
                    });
            },
        }
    });
    </script>
    <script type="text/x-template" id="cm-func-item-pos-template">
        <b-list-group-item v-bind:key="item.ID">
          <b-row class="mr-1">
              <b-col align-self="start">
                  <b-row class="ml-0">
                      <span>
                          <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                      </span>
                  </b-row>
              <table class="table-responsive table-sm">
                  <tbody>
                      <tr>
                          <td v-if="item.Receiver" class="pl-0 pr-0">func (<b :title="item.Receiver.KindString" v-bind:class="{ 'selected-warning': item.Receiver.Checked }">{{ item.Receiver.TypeString }}</b>).<b :title="func.Signature">{{ func.Name }}</b>{{func.Parameters == null ? "( )" : "" }}</td>
                          <td v-if="!item.Receiver" class="pl-0 pr-0">func <b :title="item.Signature">{{ item.Name }}</b>{{func.Parameters == null ? "( )" : "" }}</td>
                          <td class="pl-0 pr-0"
                            v-for="(param, index) in func.Parameters"
                            >
                            <cm-type
                              v-bind:elem="param"
                              v-bind:index="index"
                              v-bind:key="item.ID + 'param' + index"
                              v-bind:total="len(func.Parameters)"
                              v-bind:class="{ 'selected-primary': param.Checked }"
                              ></cm-type>
                          </td>
                            
                          <td class="pl-0 pr-0"
                            v-for="(res, index) in func.Results"
                            >
                            <cm-type
                              v-bind:elem="res"
                              v-bind:index="index"
                              v-bind:key="item.ID + 'result' + index"
                              v-bind:total="len(func.Results)"
                              v-bind:class="{ 'selected-success': res.Checked }"
                              ></cm-type>
                          </td>
                          <td>
                            <span v-for="comment in item.Comments" class="text-comment documentation">// {{ comment }}</span>
                          </td>
                      </tr>
                      <tr>
                        <td v-if="item.Receiver" class="pl-0 pr-0">
                          <b-form-checkbox 
                            class="d-flex justify-content-center checkbox-warning"
                            @change="onChangeFuncPos(item, 0, $event)"
                            v-model="item.Receiver.Checked"
                            switch
                          ></b-form-checkbox>
                        </td>
                        <td v-if="!item.Receiver" class="pl-0 pr-0">&nbsp;</td>
                        <td v-for="(param, index) in func.Parameters" class="pl-0 pr-0">
                          <b-form-checkbox 
                            class="d-flex justify-content-center"
                            @change="onChangeFuncPos(item, item.Receiver?1+index:index, $event)"
                            v-model="param.Checked"
                            switch
                          ></b-form-checkbox>
                        </td>
                        <td v-for="(res, index) in func.Results" class="pl-0 pr-0">
                          <b-form-checkbox 
                            class="d-flex justify-content-center checkbox-success"
                            @change="onChangeFuncPos(item, item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index, $event)"
                            v-model="res.Checked"
                            switch
                          ></b-form-checkbox>
                        </td>
                      </tr>
                  </tbody>
                  </table>
              </b-col>
          </b-row>
      </b-list-group-item>
    </script>

    <script type="text/javascript">
    Vue.component('cm-func-item-flow', {
        props: ['item', 'func'],
        template: "#cm-func-item-flow-template",
        computed: {},
        updated(){
          this.$root.drawAllArrowsForFuncs();
        },
        methods: {
            cc: cc,
            len: len,
            newEdge: newEdge,
            remChildren: remChildren,
            drawAnArrow: drawAnArrow,
            onChangeFuncFlow(item, blockIndex, key, index, value) {
                // - Send the update to the API
                // - Save the response in this.$root.$data.xspec
                // - The UI is bind to this.$root.$data.xspec
                console.log("Modifying func Flow selectors ...");
                
                console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
                console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
                console.log(item.ID, blockIndex, key, index, value)

                let rPath = this.$root.$data.currentPackage.path;
                let rVersion = this.$root.$data.currentPackage.version;
                let rModel = this.$root.$data.context.modelName;
                let rMethod = this.$root.$data.context.methodName;

                let payload = {
                    "Where": {
                      "Path": rPath,
                      "Version": rVersion,
                      "Model": rModel,
                      "Method": rMethod
                    },
                    "What": {
                      "FuncID": item.ID
                    },
                    "Flow": {
                      "BlockIndex": blockIndex,
                      "Key": key,
                      "Index": index,
                      "Value": value
                    }
                }
                console.log(payload);

                let url = '/api/spec/funcs';
                fetch(url, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$root.$data.xspec = json;
                        this.$root.drawArrowsFor(blockIndex, item);
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.$root.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            addBlock(fn) {
              // TODO:
              // - can add a block if at least one true inside Inp or Out.
                let width = this.len(fn.Flows.Blocks[0].Inp);
                fn.Flows.Blocks.push({ Inp: this.$root.newBoolArray(width), Out: this.$root.newBoolArray(width) });
            },
            deleteBlock(blockIndex, item) {
                console.log("Deleting block from a flow selector...");

                console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
                console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
                console.log(item.ID, "; BlockIndex:", blockIndex)

                let rPath = this.$root.$data.currentPackage.path;
                let rVersion = this.$root.$data.currentPackage.version;
                let rModel = this.$root.$data.context.modelName;
                let rMethod = this.$root.$data.context.methodName;

                let payload = {
                    "Where": {
                      "Path": rPath,
                      "Version": rVersion,
                      "Model": rModel,
                      "Method": rMethod
                    },
                    "What": {
                      "FuncID": item.ID
                    },
                    "Flow": {
                      "BlockIndex": blockIndex,
                    }
                }
                console.log(payload);

                let url = '/api/spec/funcs/flow/blocks';
                fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$root.$data.xspec = json;
                        item.Flows.Blocks.splice(blockIndex, 1);
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.$root.makeToast("danger", "Error", body.error);
                        });
                    });
            },
            onChangeEnabled(value, item) {
                console.log("Enabling/disabling a flow selector...");

                console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
                console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
                console.log(item.ID, value)

                let rPath = this.$root.$data.currentPackage.path;
                let rVersion = this.$root.$data.currentPackage.version;
                let rModel = this.$root.$data.context.modelName;
                let rMethod = this.$root.$data.context.methodName;

                let payload = {
                    "Where": {
                      "Path": rPath,
                      "Version": rVersion,
                      "Model": rModel,
                      "Method": rMethod
                    },
                    "What": {
                      "FuncID": item.ID
                    },
                    "Flow": {
                      "Enable": value,
                    }
                }
                console.log(payload);

                let url = '/api/spec/funcs/flow/enable';
                fetch(url, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    })
                    .then(response => {
                        if (response.ok) {
                            return response.json()
                        } else {
                            throw response;
                        }
                    })
                    .then(json => {
                        this.$root.$data.xspec = json;
                    })
                    .catch((error) => {
                        console.error('Error:', error);
                        error.json().then((body) => {
                            this.$root.makeToast("danger", "Error", body.error);
                        });
                    });
            },
        }
    });
    </script>
    <script type="text/x-template" id="cm-func-item-flow-template">
        <b-list-group-item v-bind:key="item.ID">
          <b-row class="ml-0">
            <div class="font-weight-bold">
                <b-form-checkbox
                  v-model="item.Flows.Enabled"
                  name="check-button"
                  switch
                  title="Click to enable/disable"
                  @change="onChangeEnabled($event, item)">
                      {{item.Flows.Enabled?'Enabled ✓':'Click to enable'}}
                </b-form-checkbox>
            </div>
          </b-row>
          <b-row
            class="mr-1"
            v-bind:class="{ 
              'text-muted': item.Flows && !item.Flows.Enabled,
            }">
              <b-col align-self="start">
                  <b-row class="ml-0">
                      <span>
                          <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                      </span>
                  </b-row>
              <div class="flow-block" v-for="(block, blockIndex) in item.Flows.Blocks">
                <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
                    <defs>
                        <marker :id="cc('arrowhead',item.ID,'block',blockIndex)" viewBox="0 0 10 10" refX="3" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                            <path d="M 0 0 L 10 5 L 0 10 z" />
                        </marker>
                    </defs>
                    <g fill="none" stroke="black" stroke-width="2" :marker-end="'url(#'+cc('arrowhead',item.ID,'block',blockIndex)+')'" :id="cc(item.ID,'block',blockIndex,'arrows')">
                    </g>
                </svg>
                <table
                  class="table-responsive table-sm"
                  >
                    <tbody>
                        <tr>
                            <td 
                              v-if="item.Receiver"
                              class="pl-0 pr-0"
                              :id="cc(item.ID,'block',blockIndex,'bl', 0)"
                              >func (<b
                                :title="item.Receiver.KindString"
                                v-bind:class="{ 
                                  'selected-primary': item.Flows && item.Flows.Blocks[blockIndex].Inp[0],
                                  'selected-warning': item.Flows && item.Flows.Blocks[blockIndex].Out[0],
                                }"
                                >{{ item.Receiver.TypeString }}</b>).<b :title="func.Signature">{{ func.Name }}</b>{{func.Parameters == null ? "( )" : "" }}</td>
                            <td v-if="!item.Receiver" class="pl-0 pr-0">func <b :title="item.Signature">{{ item.Name }}</b>{{func.Parameters == null ? "( )" : "" }}</td>
                            
                            <td class="pl-0 pr-0"
                              v-for="(param, index) in func.Parameters"
                              :id="cc(item.ID,'block',blockIndex,'bl', item.Receiver?1+index:index)"
                              >
                              <cm-type
                                v-bind:elem="param"
                                v-bind:index="index"
                                v-bind:key="item.ID + 'param' + index"
                                v-bind:total="len(func.Parameters)"
                                v-bind:class="{
                                    'selected-primary': item.Flows && (item.Flows.Blocks[blockIndex].Inp[ item.Receiver?1+index:index ]),
                                    'selected-warning': item.Flows && (item.Flows.Blocks[blockIndex].Out[ item.Receiver?1+index:index ]) 
                                 }"
                                ></cm-type>
                            </td>
                              
                            <td class="pl-0 pr-0"
                              v-for="(res, index) in func.Results"
                              :id="cc(item.ID,'block',blockIndex,'bl', item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index)"
                              >
                              <cm-type
                                v-bind:elem="res"
                                v-bind:index="index"
                                v-bind:key="item.ID + 'result' + index"
                                v-bind:total="len(func.Results)"
                                v-bind:class="{
                                    'selected-primary': item.Flows && (item.Flows.Blocks[blockIndex].Inp[ item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index ]),
                                    'selected-warning': item.Flows && (item.Flows.Blocks[blockIndex].Out[ item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index ]),
                                     }"
                                ></cm-type>
                            </td>
                            <td>
                              <span v-for="comment in item.Comments" class="text-comment documentation">// {{ comment }}</span>
                            </td>
                        </tr>
                         <!--checkboxes for input -->
                        <tr>
                          <td v-if="item.Receiver" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center"
                              @change="onChangeFuncFlow(item, blockIndex, 'Inp', 0, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Inp[0]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                          <td v-if="!item.Receiver" class="pl-0 pr-0">&nbsp;</td>
                          <td v-for="(param, index) in func.Parameters" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center"
                              @change="onChangeFuncFlow(item, blockIndex, 'Inp', item.Receiver?1+index:index, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Inp[ item.Receiver?1+index:index ]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                          <td v-for="(res, index) in func.Results" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center"
                              @change="onChangeFuncFlow(item, blockIndex, 'Inp', item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Inp[ item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index ]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                        </tr>
                         <!--checkboxes for output -->
                        <tr>
                          <td v-if="item.Receiver" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center checkbox-warning"
                              @change="onChangeFuncFlow(item, blockIndex, 'Out', 0, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Out[0]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                          <td v-if="!item.Receiver" class="pl-0 pr-0">&nbsp;</td>
                          <td v-for="(param, index) in func.Parameters" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center checkbox-warning"
                              @change="onChangeFuncFlow(item, blockIndex, 'Out', item.Receiver?1+index:index, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Out[ item.Receiver?1+index:index ]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                          <td v-for="(res, index) in func.Results" class="pl-0 pr-0">
                            <b-form-checkbox 
                              class="d-flex justify-content-center checkbox-warning"
                              @change="onChangeFuncFlow(item, blockIndex, 'Out', item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index, $event)"
                              v-model="item.Flows.Blocks[blockIndex].Out[ item.Receiver?1+len(func.Parameters)+index:len(func.Parameters)+index ]"
                              switch
                              :disabled="!item.Flows.Enabled"
                            ></b-form-checkbox>
                          </td>
                        </tr>
                    </tbody>
                  </table>
                  <div class="flow-block-index-indicator" :title="'Block #' + blockIndex">
                    #{{blockIndex}}
                  </div>
                  <div class="text-center">
                      <b-button
                        v-if="item.Flows.Blocks.length > 1"
                        class="btn-danger flow-block-trash-icon"
                        size="sm"
                        @click="deleteBlock(blockIndex, item)"
                        title="Click to delete this block"
                        :disabled="!item.Flows.Enabled"> <b-icon icon="trash-fill"></b-icon> </b-button>
                  </div>
                </div>
                <div class="text-left">
                    <b-button
                      size="sm"
                      variant="success"
                      @click="addBlock(item)"
                      :disabled="!item.Flows.Enabled"
                      title="Add another block with different flow conditions"><b-icon icon="plus-square"></b-icon> Add new block</b-button>
                </div>
              </b-col>
          </b-row>
      </b-list-group-item>
    </script>

    <script type="text/javascript">
    Vue.component('cm-type', {
        methods: {
            cc: cc,
            len: len,
        },
        props: ['elem', 'index', 'total'],
        template: "#cm-type-template"
    });
    </script>
    <script type="text/x-template" id="cm-type-template">
        <span :title="elem.KindString" class="text-monospace float-left text-truncate">{{index==0 ?"(":""}}{{elem.VarName ? elem.VarName+" ":""}}<b>{{elem.TypeString}}</b>{{index < total - 1 ? ",&nbsp;" : "" }}{{index==total - 1 ?")":""}}</span>
    </script>
    <script type="text/javascript">
    Vue.component('cm-tm-item', {
        props: ['item'],
        template: "#cm-tm-item-template"
    });
    </script>
    <script type="text/x-template" id="cm-tm-item-template">
        <b-list-group-item v-bind:key="item.ID">
          <b-row class="mr-1">
              <b-col align-self="start">
                  <span>
                      <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                  </span>
                  <span class="text-monospace float-left text-truncate">
                      <small>{{item.Func.Signature}}</small> <span v-for="comment in item.Comments" class="text-comment documentation" title="This is a comment">// {{ comment }}</span>
                  </span>
              </b-col>
          </b-row>
      </b-list-group-item>
    </script>
    <script type="text/javascript">
    Vue.component('cm-it-item', {
        props: ['item'],
        template: "#cm-it-item-template"
    });
    </script>
    <script type="text/x-template" id="cm-it-item-template">
        <b-list-group-item v-bind:key="item.ID">
          <b-row class="mr-1">
              <b-col align-self="start">
                  <span>
                      <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                  </span>
                  <span class="text-monospace float-left text-truncate">
                      <small>{{item.Func.Signature}}</small> <span v-for="comment in item.Comments" class="text-comment documentation" title="This is a comment">// {{ comment }}</span>
                  </span>
              </b-col>
          </b-row>
      </b-list-group-item>
    </script>
    <script type="text/javascript">
    Vue.component('cm-struct-item', {
        computed: {
        },
        methods: {
            cc: cc,
            onChangeStructField(value, struct, field) {
              console.log("Modifying struct selectors ...");

              console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
              console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
              console.log(value, struct.ID, field.ID)


              let rPath = this.$root.$data.currentPackage.path;
              let rVersion = this.$root.$data.currentPackage.version;
              let rModel = this.$root.$data.context.modelName;
              let rMethod = this.$root.$data.context.methodName;

              let payload = {
                  "Where": {
                    "Path": rPath,
                    "Version": rVersion,
                    "Model": rModel,
                    "Method": rMethod
                  },
                  "What": {
                    "StructID": struct.ID,
                    "FieldID": field.ID,
                    "Value": value
                  }
              }
              console.log(payload);

              let url = '/api/spec/structs';
              fetch(url, {
                      method: 'PATCH',
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(payload),
                  })
                  .then(response => {
                      if (response.ok) {
                          return response.json()
                      } else {
                          throw response;
                      }
                  })
                  .then(json => {
                      this.$root.$data.xspec = json;
                  })
                  .catch((error) => {
                      console.error('Error:', error);
                      error.json().then((body) => {
                          this.$root.makeToast("danger", "Error", body.error);
                      });
                  });
            }
        },
        props: ['item'],
        template: "#cm-struct-item-template"
    });
    </script>
    <script type="text/x-template" id="cm-struct-item-template">
        <b-list-group-item v-bind:key="item.ID">
              <b-row class="ml-1">
                  <span>
                      <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                      <div v-for="comment in item.Comments" class="documentation text-comment" title="This is a comment">// {{ comment }}</div>
                  </span>
              </b-row>
              <b-row class="ml-1">
                  <span>type <b>{{item.TypeName}}</b> struct {</span>
              </b-row>
              <table class="table-responsive table-sm table-hover">
                  <tbody>
                      <template v-for="(embedded, fieldIndex) in item.Embedded">
                          <tr v-for="doc in embedded.Docs" title="This is a doc">
                              <td colspan="3" class="comment-cell">
                                  <span class="documentation pl-4">// {{ doc }}</span>
                              </td>
                          </tr>
                          <tr>
                              <td class="pt-1 pb-1" :title="'Embedded type: '+embedded.KindString">
                                  <span class="pl-4" style="color: rgb(0, 125, 156);font-weight: bold;">
                                      {{embedded.TypeString}}
                                  </span>
                              </td>
                              <td class="pt-1 pb-1">
                                  <span v-for="comment in embedded.Comments" class="text-comment documentation" title="This is a comment">// {{ comment }}</span>
                              </td>
                          </tr>
                      </template>
                      <template v-for="(field, fieldIndex) in item.Fields">
                          <tr v-for="doc in field.Docs" title="This is a doc">
                              <td colspan="3" class="comment-cell">
                                  <span class="documentation pl-4">// {{ doc }}</span>
                              </td>
                          </tr>
                          <tr v-bind:class="{ 'selected-primary': field.Checked }">
                              <td class="pt-1 pb-1">
                                  <span class="pl-4">
                                      {{field.VarName}}
                                  </span>
                              </td>
                              <td class="pt-1 pb-1">
                                  <b-form-checkbox
                                    :id="cc('checkbox',field.ID)"
                                    v-model="field.Checked"
                                    switch
                                    @change="onChangeStructField($event, item, field)"
                                  ></b-form-checkbox>
                              </td>
                              <td class="pt-1 pb-1" :title="field.KindString">
                                  <span>
                                      {{field.TypeString}}
                                  </span>
                              </td>
                              <td class="pt-1 pb-1">
                                  <span v-for="comment in field.Comments" class="text-comment documentation" title="This is a comment">// {{ comment }}</span>
                              </td>
                          </tr>
                      </template>
                  </tbody>
              </table>
              <b-row class="ml-1">
                  <span>}</span>
              </b-row>
          </b-list-group-item>
    </script>

    <script type="text/javascript">
    Vue.component('cm-type-item', {
        computed: {
        },
        methods: {
            cc: cc,
            onChangeType(value, type) {
              console.log("Modifying type selector ...");

              console.log(this.$root.$data.currentPackage.path, this.$root.$data.currentPackage.version)
              console.log("model:", this.$root.$data.context.modelName, "method:", this.$root.$data.context.methodName)
              console.log(value, type.ID)


              let rPath = this.$root.$data.currentPackage.path;
              let rVersion = this.$root.$data.currentPackage.version;
              let rModel = this.$root.$data.context.modelName;
              let rMethod = this.$root.$data.context.methodName;

              let payload = {
                  "Where": {
                    "Path": rPath,
                    "Version": rVersion,
                    "Model": rModel,
                    "Method": rMethod
                  },
                  "What": {
                    "TypeID": type.ID,
                    "Value": value
                  }
              }
              console.log(payload);

              let url = '/api/spec/types';
              fetch(url, {
                      method: 'PATCH',
                      headers: {
                          'Content-Type': 'application/json',
                      },
                      body: JSON.stringify(payload),
                  })
                  .then(response => {
                      if (response.ok) {
                          return response.json()
                      } else {
                          throw response;
                      }
                  })
                  .then(json => {
                      this.$root.$data.xspec = json;
                  })
                  .catch((error) => {
                      console.error('Error:', error);
                      error.json().then((body) => {
                          this.$root.makeToast("danger", "Error", body.error);
                      });
                  });
            }
        },
        props: ['item'],
        template: "#cm-type-item-template"
    });
    </script>
    <script type="text/x-template" id="cm-type-item-template">
        <b-list-group-item v-bind:key="item.ID">
              <b-row class="ml-1">
                  <span>
                      <div v-for="doc in item.Docs" title="This is a doc" class="documentation">// {{ doc }}</div>
                      <div v-for="comment in item.Comments" class="documentation text-comment" title="This is a comment">// {{ comment }}</div>
                  </span>
              </b-row>
              <table class="table-responsive table-sm table-hover">
                  <tbody>
                    <tr>
                        <td class="ml-1">
                          <span 
                            v-bind:class="{ 'selected-primary': item.Checked }"
                            :title="item.KindString"
                            class="text-wrap"
                            >type <b>{{item.TypeName}}</b>, which is {{item.KindString}}</span>
                        </td>
                    </tr>
                    <tr class="d-flex justify-content-center">
                        <td class="ml-1">
                            <span>
                              <b-form-checkbox
                                :id="cc('checkbox',item.ID)"
                                v-model="item.Checked"
                                switch
                                @change="onChangeType($event, item)"
                              ></b-form-checkbox>
                            </span>
                        </td>
                    </tr>
                  </tbody>
              </table>
          </b-list-group-item>
    </script>
</body>

</html>