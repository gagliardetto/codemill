package tainttracking

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"sort"

	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/codebox/gogentools"
	"github.com/gagliardetto/codemill/x"
	"github.com/gagliardetto/feparser"
	"github.com/gagliardetto/golang-go/cmd/go/not-internal/search"
	. "github.com/gagliardetto/utilz"
)

const (
	// NOTE: hardcoded inside TestQueryContent const.
	InlineExpectationsTestTag = "$SinkingSource" // Must start with a $ sign.
)

func Tag() Code {
	return Comment(InlineExpectationsTestTag)
}

const (
	TestQueryContent = `
import go
import TestUtilities.InlineExpectationsTest

class Configuration extends TaintTracking::Configuration {
  Configuration() { this = "test-configuration" }

  override predicate isSource(DataFlow::Node source) {
    exists(Function fn | fn.hasQualifiedName(_, "source") | source = fn.getACall().getResult())
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(Function fn | fn.hasQualifiedName(_, "sink") | sink = fn.getACall().getAnArgument())
  }
}

class TaintTrackingTest extends InlineExpectationsTest {
  TaintTrackingTest() { this = "TaintTrackingTest" }

  override string getARelevantTag() { result = "SinkingSource" }

  override predicate hasActualResult(string file, int line, string element, string tag, string value) {
    tag = "SinkingSource" and
    exists(DataFlow::Node sink | any(Configuration c).hasFlow(_, sink) |
      element = sink.toString() and
      value = "" and
      sink.hasLocationInfo(file, line, _, _, _)
    )
  }
}

`
)

func NewTestFile(includeBoilerplace bool) *File {
	file := NewFile("main")
	// Set a prefix to avoid collision between variable names and packages:
	file.PackagePrefix = "cql"
	// Add comment to file:
	file.HeaderComment("Code generated by https://github.com/gagliardetto. DO NOT EDIT.")

	if includeBoilerplace {
		{
			// main function:
			file.Func().Id("main").Params().Block()
		}
		{
			// sink function:
			code := Func().
				Id("sink").
				Params(Id("v").Interface()).
				Block()
			file.Add(code.Line())
		}
		{
			// link function (Used in tests to transmit taint from param 0 into param 1):
			code := Func().
				Id("link").
				Params(Id("from").Interface(), Id("into").Interface()).
				Block()
			file.Add(code.Line())
		}
		{
			// The `source` function returns a new tainted thing:
			code := Func().
				Id("source").
				Params().
				Interface().
				Block(Return(Nil()))
			file.Add(code.Line())
		}
	}
	return file
}

var (
	IncludeCommentsInGeneratedGo bool
)

func (han *Handler) GenerateGo(parentDir string, mdl *x.XModel) error {
	// TODO
	Sfln(
		"%s: Generating go code for model %q into %q parentDir",
		Kind,
		mdl.Name,
		parentDir,
	)

	if err := mdl.Validate(); err != nil {
		return err
	}
	if err := han.Validate(mdl); err != nil {
		return err
	}
	// TODO:
	// - Validate FlowBlocks.

	// Check if there are multiple versions of a same package:
	mods := mdl.ListModules()
	if x.HasMultiversion(mods) {
		Ln(RedBG("Has multiversion"))
	}
	// If there are no multiple versions of the same module,
	// that means we can save all the code to one file.
	allInOneFile := !x.HasMultiversion(mods)

	// Create the directory for the tests for this model:
	outDir := filepath.Join(parentDir, feparser.NewCodeQlName(mdl.Name))
	MustCreateFolderIfNotExists(outDir, os.ModePerm)

	// Assuming the validation has already been done:
	self := mdl.Methods[0]

	if len(self.Selectors) == 0 {
		Infof("No selectors found for %q method.", self.Name)
		return nil
	}

	allPathVersions := func() []string {
		res := make([]string, 0)
		mods := mdl.ListModules()
		for _, mod := range mods {
			res = append(res, mod.PathVersionClean())
		}
		sort.Strings(res)
		return res
	}()

	file := NewTestFile(true)
	ndb := x.NewNameDB()

	for _, pathVersion := range allPathVersions {
		ndbthis := ndb.Child(pathVersion)
		if !allInOneFile {
			// Reset file:
			file = NewTestFile(true)
		}
		codez := make([]Code, 0)

		b2fe, b2tm, b2itm, err := x.GroupFuncSelectors(self)
		if err != nil {
			Fatalf("Error while GroupFuncSelectors: %s", err)
		}

		testCounter := 0

		{
			cont, ok := b2fe[pathVersion]
			if ok {
				code := BlockFunc(
					func(groupCase *Group) {

						for _, funcQual := range cont {
							fn := x.GetFuncQualifier(funcQual)
							thing := fn.(*feparser.FEFunc)

							x.AddImportsFromFunc(file, thing)
							ndbthis.Second(thing.PkgPath, thing.Name)
							ndbthis.FromFETypes(thing.Parameters...)
							ndbthis.FromFETypes(thing.Results...)

							{
								if !funcQual.Flows.Enabled {
									continue
								}
								groupCase.Comment(thing.Signature)

								blocksOfCases := generateGoTestBlock_Func(
									file,
									thing,
									funcQual,
									&testCounter,
								)
								if len(blocksOfCases) == 1 {
									groupCase.Add(blocksOfCases...)
								} else {
									groupCase.Block(blocksOfCases...)
								}
							}

						}
					})
				codez = append(codez,
					Comment("Taint-tracking through functions.").
						Line().
						Add(code),
				)
			}
		}
		{
			cont, ok := b2tm[pathVersion]
			if ok {
				codezTypeMethods := make([]Code, 0)
				keys := func(v map[string][]*x.FuncQualifier) []string {
					res := make([]string, 0)
					for key := range v {
						res = append(res, key)
					}
					sort.Strings(res)
					return res
				}(cont)
				for _, receiverTypeID := range keys {
					methodQualifiers := cont[receiverTypeID]
					if len(methodQualifiers) == 0 {
						continue
					}

					qual := methodQualifiers[0]
					source := x.GetCachedSource(qual.Path, qual.Version)
					if source == nil {
						Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
					}
					// Find receiver type:
					typ := x.FindTypeByID(source, receiverTypeID)
					if typ == nil {
						Fatalf("Type not found: %q", receiverTypeID)
					}

					gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)
					ndbthis.First(pathVersion, typ.TypeName)

					code := BlockFunc(
						func(groupCase *Group) {

							for _, methodQual := range methodQualifiers {
								fn := x.GetFuncQualifier(methodQual)
								thing := fn.(*feparser.FETypeMethod)
								x.AddImportsFromFunc(file, fn)

								{
									if !methodQual.Flows.Enabled {
										continue
									}
									groupCase.Comment(thing.Func.Signature)
									ndbthis.FromFETypes(thing.Func.Parameters...)
									ndbthis.FromFETypes(thing.Func.Results...)

									blocksOfCases := generateGoTestBlock_Method(
										file,
										thing,
										methodQual,
										&testCounter,
									)
									if len(blocksOfCases) == 1 {
										groupCase.Add(blocksOfCases...)
									} else {
										groupCase.Block(blocksOfCases...)
									}
								}

							}
						})
					// TODO: what if no flows are enabled? Check that before adding the comment.
					codezTypeMethods = append(codezTypeMethods,
						Commentf("Taint-tracking through method calls on %s.", typ.QualifiedName).
							Line().
							Add(code),
					)
				}
				codez = append(codez,
					Comment("Taint-tracking through method calls.").
						Line().
						Block(codezTypeMethods...),
				)
			}
		}

		{
			cont, ok := b2itm[pathVersion]
			if ok {
				codezIfaceMethods := make([]Code, 0)
				keys := func(v map[string][]*x.FuncQualifier) []string {
					res := make([]string, 0)
					for key := range v {
						res = append(res, key)
					}
					sort.Strings(res)
					return res
				}(cont)
				for _, receiverTypeID := range keys {
					methodQualifiers := cont[receiverTypeID]
					if len(methodQualifiers) == 0 {
						continue
					}

					qual := methodQualifiers[0]
					source := x.GetCachedSource(qual.Path, qual.Version)
					if source == nil {
						Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
					}
					// Find receiver type:
					typ := x.FindTypeByID(source, receiverTypeID)
					if typ == nil {
						Fatalf("Type not found: %q", receiverTypeID)
					}

					gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)
					ndbthis.First(pathVersion, typ.TypeName)

					code := BlockFunc(
						func(groupCase *Group) {

							for _, methodQual := range methodQualifiers {
								fn := x.GetFuncQualifier(methodQual)
								thing := fn.(*feparser.FEInterfaceMethod)
								x.AddImportsFromFunc(file, fn)

								{
									if !methodQual.Flows.Enabled {
										continue
									}
									groupCase.Comment(thing.Func.Signature)
									ndbthis.FromFETypes(thing.Func.Parameters...)
									ndbthis.FromFETypes(thing.Func.Results...)

									converted := feparser.FEIToFET(thing)
									blocksOfCases := generateGoTestBlock_Method(
										file,
										converted,
										methodQual,
										&testCounter,
									)
									if len(blocksOfCases) == 1 {
										groupCase.Add(blocksOfCases...)
									} else {
										groupCase.Block(blocksOfCases...)
									}
								}
							}
						})
					codezIfaceMethods = append(codezIfaceMethods,
						Commentf("Taint-tracking through method calls on %s interface.", typ.QualifiedName).
							Line().
							Add(code),
					)
				}

				codez = append(codez,
					Comment("Taint-tracking through interface method calls.").
						Line().
						Block(codezIfaceMethods...),
				)
			}
		}

		{
			file.Commentf("Package %s", pathVersion)
			file.Func().Id(feparser.FormatCodeQlName(pathVersion)).Params().Block(codez...)
		}

		if !allInOneFile {
			{
				for _, path := range ndbthis.Paths() {
					isStd := search.IsStandardImportPath(path)
					if !isStd {
						pathToTypeNames, pathToFuncAndVarNames := ndbthis.ReturnByPaths()
						file.Comment(x.FormatDepstubberComment(path, pathToTypeNames[path], pathToFuncAndVarNames[path]))
					}
				}
				file.Comment("//go:generate depstubber -write_module_txt").Line()

				file.Comment("Taint-tracking through package: " + pathVersion)
			}

			pkgDstDirpath := filepath.Join(outDir, feparser.FormatID("Model", mdl.Name, "For", feparser.FormatCodeQlName(pathVersion)))
			MustCreateFolderIfNotExists(pkgDstDirpath, os.ModePerm)

			assetFileName := feparser.FormatID("Model", mdl.Name, "For", feparser.FormatCodeQlName(pathVersion)) + ".go"
			if err := x.SaveGoFile(pkgDstDirpath, assetFileName, file); err != nil {
				Fatalf("Error while saving go file: %s", err)
			}

			if err := x.WriteGoModFile(pkgDstDirpath, pathVersion); err != nil {
				Fatalf("Error while saving go.mod file: %s", err)
			}
			if err := x.WriteCodeQLTestQuery(pkgDstDirpath, x.DefaultCodeQLTestFileName, TestQueryContent); err != nil {
				Fatalf("Error while saving <name>.ql file: %s", err)
			}
			if err := x.WriteEmptyCodeQLDotExpectedFile(pkgDstDirpath, x.DefaultCodeQLTestFileName); err != nil {
				Fatalf("Error while saving <name>.expected file: %s", err)
			}
		}
	}

	if allInOneFile {
		{
			for _, path := range ndb.Paths() {
				isStd := search.IsStandardImportPath(path)
				if !isStd {
					pathToTypeNames, pathToFuncAndVarNames := ndb.ReturnByPaths()
					file.Comment(x.FormatDepstubberComment(path, pathToTypeNames[path], pathToFuncAndVarNames[path]))
				}
			}
			file.Comment("//go:generate depstubber -write_module_txt").Line()
		}

		pkgDstDirpath := outDir
		MustCreateFolderIfNotExists(pkgDstDirpath, os.ModePerm)

		assetFileName := feparser.FormatID("Model", mdl.Name) + ".go"
		if err := x.SaveGoFile(pkgDstDirpath, assetFileName, file); err != nil {
			Fatalf("Error while saving go file: %s", err)
		}

		pathVersions := ndb.PathVersions()

		if err := x.WriteGoModFile(pkgDstDirpath, pathVersions...); err != nil {
			Fatalf("Error while saving go.mod file: %s", err)
		}
		if err := x.WriteCodeQLTestQuery(pkgDstDirpath, x.DefaultCodeQLTestFileName, TestQueryContent); err != nil {
			Fatalf("Error while saving <name>.ql file: %s", err)
		}
		if err := x.WriteEmptyCodeQLDotExpectedFile(pkgDstDirpath, x.DefaultCodeQLTestFileName); err != nil {
			Fatalf("Error while saving <name>.expected file: %s", err)
		}
	}
	return nil
}

// Comments adds comments to a Group (if enabled), and returns the group.
func Comments(group *Group, comments ...string) *Group {
	if IncludeCommentsInGeneratedGo {
		for _, comment := range comments {
			group.Line().Comment(comment)
		}
	}
	return group
}

func newStatement() *Statement {
	return &Statement{}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
type StatementAndName struct {
	Statement    *Statement
	TestFuncName string
}

func validateBlockLen(fn x.FuncInterface, blocks ...*feparser.FlowBlock) error {
	for blockIndex, block := range blocks {
		if blockInpLen := len(block.Inp); blockInpLen != fn.Len() {
			return fmt.Errorf("block %v: .Inp has wrong len: %v", blockIndex, blockInpLen)
		}
		if blockOutpLen := len(block.Outp); blockOutpLen != fn.Len() {
			return fmt.Errorf("block %v: .Outp has wrong len: %v", blockIndex, blockOutpLen)
		}
	}
	return nil
}

// for each block, generate a golang test function for each inp and outp combination.
func generateGoTestBlock_Func(file *File, fe *feparser.FEFunc, qual *x.FuncQualifier, testCounter *int) []Code {
	childBlocks := make([]Code, 0)
	for blockIndex, block := range qual.Flows.Blocks {
		for inpIndex, inpOk := range block.Inp {
			if !inpOk {
				continue
			}
			for outIndex, outpOk := range block.Out {
				if !outpOk {
					continue
				}
				childBlock := generateGoChildBlock_Func(
					file,
					fe,
					inpIndex,
					outIndex,
					*testCounter,
				)
				{
					if childBlock != nil {
						*testCounter++
						childBlocks = append(childBlocks, childBlock)
					} else {
						Warnf(Sf("NOTHING GENERATED; block %v, inp %v, outp %v", blockIndex, inpIndex, outIndex))
					}
				}
			}
		}
	}

	return childBlocks
}

// declare `name := source(1).(Type)`
func ComposeTypeAssertion(file *File, group *Group, varName string, typ types.Type, isVariadic bool, counter int) {
	assertContent := newStatement()
	if isVariadic {
		if slice, ok := typ.(*types.Slice); ok {
			gogentools.ComposeTypeDeclaration(file, assertContent, slice.Elem())
		} else {
			gogentools.ComposeTypeDeclaration(file, assertContent, typ)
		}
	} else {
		gogentools.ComposeTypeDeclaration(file, assertContent, typ)
	}
	group.Id(varName).Op(":=").Id("source").Call().Assert(assertContent)
}
func DoGroup(f func(*Group)) *Statement {
	g := &Group{}
	g.CustomFunc(Options{
		Multi: true,
	}, f)
	s := newStatement()
	*s = append(*s, g)
	return s
}
func generateGoChildBlock_Func(file *File, fe *feparser.FEFunc, inpIndex int, outIndex int, counter int) *Statement {

	inpElem, _, inpRelIndex, err := fe.GetRelativeElement(inpIndex)
	if err != nil {
		panic(err)
	}
	outElem, _, outRelIndex, err := fe.GetRelativeElement(outIndex)
	if err != nil {
		panic(err)
	}
	Parameter := feparser.ElementParameter
	Result := feparser.ElementResult

	switch {
	case inpElem == Parameter && outElem == Parameter:
		return generate_ParaFuncPara(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Parameter && outElem == Result:
		return generate_ParaFuncResu(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Result && outElem == Parameter:
		return generate_ResuFuncPara(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Result && outElem == Result:
		return generate_ResuFuncResu(file, fe, inpRelIndex, outRelIndex, counter)
	default:
		panic(Sf("unhandled case: inp.Element %v, out.Element %v", inpElem, outElem))
	}
}

func generate_ParaFuncPara(file *File, fe *feparser.FEFunc, indexIn int, indexOut int, counter int) *Statement {
	// from: param
	// medium: func
	// into: param

	in := fe.Parameters[indexIn]
	out := fe.Parameters[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal().GetType(), out.GetOriginal().IsVariadic())

			Comments(groupCase,
				"Call the function that transfers the taint",
				Sf("from the parameter `%s` to parameter `%s`;", inVarName, outVarName),
				Sf("`%s` is now tainted.", outVarName),
			)

			gogentools.ImportPackage(file, fe.PkgPath, fe.PkgName)

			groupCase.Qual(fe.PkgPath, fe.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexIn || i == indexOut
						if isConsidered {
							call.Id(fe.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})

	return code
}

func runTidy() {
	// TODO:
	// https://github.com/golang/go/blob/846dce9d05f19a1f53465e62a304dea21b99f910/src/cmd/go/internal/modcmd/tidy.go
}
func generate_ParaFuncResu(file *File, fe *feparser.FEFunc, indexIn int, indexOut int, counter int) *Statement {
	// from: param
	// medium: func
	// into: result

	in := fe.Parameters[indexIn]
	out := fe.Results[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase,
				"Call the function that transfers the taint",
				Sf("from the parameter `%s` to result `%s`", inVarName, outVarName),
				Sf("(`%s` is now tainted).", outVarName),
			)
			groupCase.ListFunc(func(resGroup *Group) {
				for i, v := range fe.Results {
					if i == indexOut {
						resGroup.Id(v.VarName)
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Qual(fe.PkgPath, fe.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexIn
						if isConsidered {
							call.Id(fe.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ResuFuncPara(file *File, fe *feparser.FEFunc, indexIn int, indexOut int, counter int) *Statement {
	// from: result
	// medium: func
	// into: param
	// NOTE: does this actually happen? It needs extra steps, right?

	in := fe.Results[indexIn]
	out := fe.Parameters[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", out.VarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal().GetType(), out.GetOriginal().IsVariadic())
			gogentools.ImportPackage(file, out.PkgPath, out.PkgName)

			Comments(groupCase,
				"Call the function that will transfer the taint",
				Sf("from the result `intermediateCQL` to parameter `%s`:", outVarName),
			)
			groupCase.ListFunc(func(resGroup *Group) {
				for i, _ := range fe.Results {
					if i == indexIn {
						resGroup.Id("intermediateCQL")
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Qual(fe.PkgPath, fe.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexOut
						if isConsidered {
							call.Id(fe.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase,
				Sf(
					"Extra step (`%s` taints `intermediateCQL`, which taints `%s`:",
					in.VarName,
					out.VarName,
				),
			)
			groupCase.Id("link").Call(Id(in.VarName), Id("intermediateCQL"))

			Comments(groupCase, Sf("Return the tainted `%s`:", out.VarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ResuFuncResu(file *File, fe *feparser.FEFunc, indexIn int, indexOut int, counter int) *Statement {
	// from: result
	// medium: func
	// into: result

	in := fe.Results[indexIn]
	out := fe.Results[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)
			gogentools.ImportPackage(file, out.PkgPath, out.PkgName)

			Comments(groupCase,
				"Call the function that transfers the taint",
				Sf("from the result `%s` to result `%s`", inVarName, outVarName),
				"(extra steps needed)",
			)
			groupCase.ListFunc(func(resGroup *Group) {
				for i, v := range fe.Results {
					if i == indexIn || i == indexOut {
						if i == indexIn {
							resGroup.Id("intermediateCQL")
						} else {
							resGroup.Id(v.VarName)
						}
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Qual(fe.PkgPath, fe.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.GetOriginal().IsVariadic())

					for _, zero := range zeroVals {
						call.Add(zero)
					}

				},
			)

			Comments(groupCase,
				Sf(
					"Extra step (`%s` taints `intermediateCQL`, which taints `%s`:",
					in.VarName,
					out.VarName,
				))
			groupCase.Id("link").Call(Id(in.VarName), Id("intermediateCQL"))

			Comments(groupCase, Sf("Return the tainted `%s`:", out.VarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}

// for each block, generate a golang test function for each inp and outp combination.
func generateGoTestBlock_Method(file *File, fe *feparser.FETypeMethod, qual *x.FuncQualifier, testCounter *int) []Code {
	childBlocks := make([]Code, 0)
	for blockIndex, block := range qual.Flows.Blocks {
		for inpIndex, inpOk := range block.Inp {
			if !inpOk {
				continue
			}
			for outIndex, outpOk := range block.Out {
				if !outpOk {
					continue
				}
				childBlock := generateChildBlock_Method(
					file,
					fe,
					inpIndex,
					outIndex,
					*testCounter,
				)
				{
					if childBlock != nil {
						*testCounter++
						childBlocks = append(childBlocks, childBlock)
					} else {
						Warnf(Sf("NOTHING GENERATED; block %v, inp %v, outp %v", blockIndex, inpIndex, outIndex))
					}
				}
			}
		}
	}

	return childBlocks
}

func generateChildBlock_Method(file *File, fe *feparser.FETypeMethod, inpIndex int, outIndex int, counter int) *Statement {
	inpElem, _, inpRelIndex, err := fe.GetRelativeElement(inpIndex)
	if err != nil {
		panic(err)
	}
	outElem, _, outRelIndex, err := fe.GetRelativeElement(outIndex)
	if err != nil {
		panic(err)
	}

	Receiver := feparser.ElementReceiver
	Parameter := feparser.ElementParameter
	Result := feparser.ElementResult

	switch {
	case inpElem == Receiver && outElem == Parameter:
		return generate_ReceMethPara(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Receiver && outElem == Result:
		return generate_ReceMethResu(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Parameter && outElem == Receiver:
		return generate_ParaMethRece(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Parameter && outElem == Parameter:
		return generate_ParaMethPara(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Parameter && outElem == Result:
		return generate_ParaMethResu(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Result && outElem == Receiver:
		return generate_ResuMethRece(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Result && outElem == Parameter:
		return generate_ResuMethPara(file, fe, inpRelIndex, outRelIndex, counter)
	case inpElem == Result && outElem == Result:
		return generate_ResuMethResu(file, fe, inpRelIndex, outRelIndex, counter)
	default:
		panic(Sf("unhandled case: inpElem %v,  outElem %v", inpElem, outElem))
	}
}
func generate_ReceMethPara(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: receiver
	// medium: method (when there is a receiver, then it must be a method medium)
	// into: param

	_ = indexIn

	in := fe.Receiver
	out := fe.Func.Parameters[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal(), in.Is.Variadic, counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal().GetType(), out.GetOriginal().IsVariadic())

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the receiver `%s` to the argument `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.Id(in.VarName).Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexOut
						if isConsidered {
							call.Id(fe.Func.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ReceMethResu(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: receiver
	// medium: method (when there is a receiver, then it must be a method medium)
	// into: result

	_ = indexIn

	in := fe.Receiver
	out := fe.Func.Results[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal(), in.Is.Variadic, counter)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the receiver `%s` to the result `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.ListFunc(func(resGroup *Group) {
				for i, v := range fe.Func.Results {
					if i == indexOut {
						resGroup.Id(v.VarName)
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Id(in.VarName).Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for _, zero := range zeroVals {
						call.Add(zero)
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ParaMethRece(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: param
	// medium: method (when there is a receiver, then it must be a method medium)
	// into: receiver

	_ = indexOut

	in := fe.Func.Parameters[indexIn]
	out := fe.Receiver

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal(), out.Is.Variadic)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the parameter `%s` to the receiver `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.Id(out.VarName).Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexIn
						if isConsidered {
							call.Id(fe.Func.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ParaMethPara(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: param
	// medium: method (when there is a receiver, then it must be a method medium)
	// into: param

	in := fe.Func.Parameters[indexIn]
	out := fe.Func.Parameters[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal().GetType(), out.GetOriginal().IsVariadic())

			Comments(groupCase, "Declare medium object/interface:")
			groupCase.Var().Id("mediumObjCQL").Qual(fe.Receiver.PkgPath, fe.Receiver.TypeName)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the parameter `%s` to the parameter `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.Id("mediumObjCQL").Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexIn || i == indexOut
						if isConsidered {
							call.Id(fe.Func.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ParaMethResu(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: param
	// medium: method (when there is a receiver, then it must be a method medium)
	// into: result

	in := fe.Func.Parameters[indexIn]
	out := fe.Func.Results[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, "Declare medium object/interface:")
			groupCase.Var().Id("mediumObjCQL").Qual(fe.Receiver.PkgPath, fe.Receiver.TypeName)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the parameter `%s` to the result `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.ListFunc(func(resGroup *Group) {
				for i, v := range fe.Func.Results {
					if i == indexOut {
						resGroup.Id(v.VarName)
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Id("mediumObjCQL").Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexIn
						if isConsidered {
							call.Id(fe.Func.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase, Sf("Return the tainted `%s`:", outVarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ResuMethRece(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: result
	// medium: method
	// into: receiver

	_ = indexOut

	in := fe.Func.Results[indexIn]
	out := fe.Receiver

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal(), out.Is.Variadic)

			Comments(groupCase,
				"Call the method that will transfer the taint",
				Sf("from the result `intermediateCQL` to receiver `%s`:", outVarName),
			)

			groupCase.ListFunc(func(resGroup *Group) {
				for i := range fe.Func.Results {
					if i == indexIn {
						resGroup.Id("intermediateCQL")
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Id(out.VarName).Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for _, zero := range zeroVals {
						call.Add(zero)
					}

				},
			)

			Comments(groupCase,
				Sf(
					"Extra step (`%s` taints `intermediateCQL`, which taints `%s`:",
					in.VarName,
					out.VarName,
				),
			)
			groupCase.Id("link").Call(Id(in.VarName), Id("intermediateCQL"))

			Comments(groupCase, Sf("Return the tainted `%s`:", out.VarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
func generate_ResuMethPara(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: result
	// medium: method
	// into: parameter

	in := fe.Func.Results[indexIn]
	out := fe.Func.Parameters[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, Sf("Declare `%s` variable:", outVarName))
			gogentools.ComposeVarDeclaration(file, groupCase, out.VarName, out.GetOriginal().GetType(), out.GetOriginal().IsVariadic())

			Comments(groupCase, "Declare medium object/interface:")
			groupCase.Var().Id("mediumObjCQL").Qual(fe.Receiver.PkgPath, fe.Receiver.TypeName)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the result `%s` to the parameter `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.ListFunc(func(resGroup *Group) {
				for i, _ := range fe.Func.Results {
					if i == indexIn {
						resGroup.Id("intermediateCQL")
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Id("mediumObjCQL").Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := i == indexOut
						if isConsidered {
							call.Id(fe.Func.Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			)

			Comments(groupCase,
				Sf(
					"Extra step (`%s` taints `intermediateCQL`, which taints `%s`:",
					in.VarName,
					out.VarName,
				),
			)
			groupCase.Id("link").Call(Id(in.VarName), Id("intermediateCQL"))

			Comments(groupCase, Sf("Return the tainted `%s`:", out.VarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}

func generate_ResuMethResu(file *File, fe *feparser.FETypeMethod, indexIn int, indexOut int, counter int) *Statement {
	// from: result
	// medium: method
	// into: result

	in := fe.Func.Results[indexIn]
	out := fe.Func.Results[indexOut]

	in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("from", in.TypeName))
	out.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("into", out.TypeName))

	inVarName := in.VarName
	outVarName := out.VarName

	code := BlockFunc(
		func(groupCase *Group) {
			Comments(groupCase, Sf("The flow is from `%s` into `%s`.", inVarName, outVarName))

			Comments(groupCase, Sf("Assume that `sourceCQL` has the underlying type of `%s`:", inVarName))
			ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic(), counter)

			Comments(groupCase, "Declare medium object/interface:")
			groupCase.Var().Id("mediumObjCQL").Qual(fe.Receiver.PkgPath, fe.Receiver.TypeName)

			Comments(groupCase,
				"Call the method that transfers the taint",
				Sf("from the result `%s` to the result `%s`", in.VarName, out.VarName),
				Sf("(`%s` is now tainted).", out.VarName),
			)

			gogentools.ImportPackage(file, fe.Func.PkgPath, fe.Func.PkgName)

			groupCase.ListFunc(func(resGroup *Group) {
				for i, v := range fe.Func.Results {
					if i == indexIn || i == indexOut {
						if i == indexIn {
							resGroup.Id("intermediateCQL")
						} else {
							resGroup.Id(v.VarName)
						}
					} else {
						resGroup.Id("_")
					}
				}
			}).Op(":=").Id("mediumObjCQL").Dot(fe.Func.Name).CallFunc(
				func(call *Group) {

					tpFun := fe.Func.GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.Func.GetOriginal().IsVariadic())

					for _, zero := range zeroVals {
						call.Add(zero)
					}

				},
			)
			Comments(groupCase,
				Sf(
					"Extra step (`%s` taints `intermediateCQL`, which taints `%s`:",
					in.VarName,
					out.VarName,
				))
			groupCase.Id("link").Call(Id(in.VarName), Id("intermediateCQL"))

			Comments(groupCase, Sf("Return the tainted `%s`:", out.VarName))
			groupCase.Id("sink").Call(Id(out.VarName)).Add(Tag())
		})
	return code
}
