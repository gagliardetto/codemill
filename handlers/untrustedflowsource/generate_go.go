package untrustedflowsource

import (
	"fmt"
	"go/types"
	"sort"

	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/codebox/gogentools"
	"github.com/gagliardetto/codemill/x"
	"github.com/gagliardetto/feparser"
	. "github.com/gagliardetto/utilz"
)

func NewTestFile(includeBoilerplace bool) *File {
	file := NewFile("main")
	// Set a prefix to avoid collision between variable names and packages:
	file.PackagePrefix = "cql"
	// Add comment to file:
	file.HeaderComment("Code generated by https://github.com/gagliardetto/codemill. DO NOT EDIT.")

	if includeBoilerplace {
		{
			// main function:
			//file.Func().Id("main").Params().Block()
		}
		{
			// sink function:
			code := Func().
				Id("sink").
				//Params(Id("id").Int(), Id("v").Interface()).
				Params(Id("v").Op("...").Interface()).
				Block()
			file.Add(code.Line())
		}
		{
			// link function (Used in tests to transmit taint from param 0 into param 1):
			code := Func().
				Id("link").
				Params(Id("from").Interface(), Id("into").Interface()).
				Block()
			file.Add(code.Line())
		}
		{
			// source function returns a new tainted thing:
			code := Func().
				Id("source").
				Params(Id("id").Int()).
				Interface().
				Block(Return(Nil()))
			file.Add(code.Line())
		}
	}
	return file
}

var (
	IncludeCommentsInGeneratedGo bool
)

func (han *Handler) GenerateGo(dir string, mdl *x.XModel) error {
	// TODO
	Sfln(
		"Generating go code for model %q into %q dir",
		mdl.Name,
		dir,
	)

	{
		// Check if there are multiple versions of a same package:
		mods := mdl.ListModules()
		if x.HasMultiversion(mods) {
			Ln(RedBG("Has multiversion"))
		}
	}
	if err := mdl.Validate(); err != nil {
		return err
	}
	if err := han.Validate(mdl); err != nil {
		return err
	}

	// Assuming the validation has already been done:
	self := mdl.Methods[0]

	if len(self.Selectors) == 0 {
		Infof("No selectors found for %q method.", self.Name)
		return nil
	}

	{
		b2fe, _, _, err := x.GroupFuncSelectors(self)
		if err != nil {
			Fatalf("Error while GroupFuncSelectors: %s", err)
		}

		{
			keys := func(v x.BasicToFEFuncs) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(b2fe)
			for _, pathVersion := range keys {
				cont := b2fe[pathVersion]

				file := NewTestFile(true)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, funcQual := range cont {
							fn := x.GetFuncQualifier(funcQual)
							thing := fn.(*feparser.FEFunc)

							gogentools.ImportPackage(file, thing.PkgPath, thing.PkgName)

							groupCase.Comment(thing.Signature)
							_, codeElements := GoGetFuncQualifierCodeElements(file, funcQual)
							groupCase.Add(codeElements...)

						}
					})

				file.Func().Id("main").Params().Add(code)
				fmt.Printf("%#v", file)
			}
		}

	}

	return nil
}

// Comments adds comments to a Group (if enabled), and returns the group.
func Comments(group *Group, comments ...string) *Group {
	if IncludeCommentsInGeneratedGo {
		for _, comment := range comments {
			group.Line().Comment(comment)
		}
	}
	return group
}
func GoGetFuncQualifierCodeElements(file *File, qual *x.FuncQualifier) (x.FuncInterface, []Code) {

	source := x.GetCachedSource(qual.Path, qual.Version)
	if source == nil {
		Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
	}
	// Find the func/type-method/interface-method:
	fn := x.FindFuncByID(source, qual.ID)
	if fn == nil {
		Fatalf("Func not found: %q", qual.ID)
	}

	codeElements := make([]Code, 0)
	parameterIndexes := make([]int, 0)
	resultIndexes := make([]int, 0)
PosLoop:
	for pos, ok := range qual.Pos {
		if !ok {
			continue PosLoop
		}

		elTyp, el, relIndex, err := fn.GetRelativeElement(pos)
		if err != nil {
			Fatalf("Error while GetRelativeElement: %s", err)
		}

		switch elTyp {
		case feparser.ElementReceiver:
			{
				code := BlockFunc(
					func(groupCase *Group) {
						source := el.(*feparser.FEReceiver)
						varName := gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("source", source.TypeName))

						gogentools.ComposeVarDeclaration(file, groupCase, varName, source.GetOriginal(), false)
					})

				codeElements = append(codeElements,
					code,
				)
			}
		case feparser.ElementParameter:
			{
				parameterIndexes = append(parameterIndexes,
					relIndex,
				)
			}
		case feparser.ElementResult:
			{
				resultIndexes = append(resultIndexes,
					relIndex,
				)
			}
		default:
			panic(Sf("Unknown type: %q", elTyp))
		}
	}

	fe := fn.(*feparser.FEFunc)
	tpFun := fe.GetOriginal().GetType().(*types.Signature)

	lenReceiver, _, _ := fn.Lengths()
	hasReceiver := lenReceiver == 1

	// Compile array of the zero values of the function parameters:
	paramZeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fe.GetOriginal().IsVariadic())

	// Compile array of the zero values of the function results:
	resultZeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Results(), fe.GetOriginal().IsVariadic())

	code := BlockFunc(
		func(groupCase *Group) {

			if hasReceiver {
				// TODO
			} else {

				// Decide parameter names, and declare variables that will be passed as those parameters:
				if len(parameterIndexes) > 0 {
					for i := range paramZeroVals {
						isConsidered := IntSliceContains(parameterIndexes, i)
						if isConsidered {
							varName := gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("param", fe.Parameters[i].VarName))
							fe.Parameters[i].VarName = varName
							gogentools.ComposeVarDeclaration(file, groupCase, varName, fe.Parameters[i].GetOriginal().GetType(), false)
						}
					}
				}

				codeResultList := Null()
				if len(resultIndexes) > 0 {
					for i := range resultZeroVals {
						isConsidered := IntSliceContains(resultIndexes, i)
						if isConsidered {
							varName := gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("result", fe.Results[i].VarName))
							fe.Results[i].VarName = varName
						}
					}

					codeResultList = ListFunc(func(resGroup *Group) {
						for i, v := range fe.Results {
							isConsidered := IntSliceContains(resultIndexes, i)
							if isConsidered {
								resGroup.Id(v.VarName)
							} else {
								resGroup.Id("_")
							}
						}
					}).Op(":=")
				}

				// Call the function, passing the considered parameters:
				groupCase.Add(codeResultList).Qual(fe.PkgPath, fe.Name).CallFunc(
					func(call *Group) {
						for i, zero := range paramZeroVals {
							isConsidered := IntSliceContains(parameterIndexes, i)
							if isConsidered {
								call.Id(fe.Parameters[i].VarName)
							} else {
								call.Add(zero)
							}
						}
					},
				)

				// Sink the parameters:
				if len(parameterIndexes) > 0 {
					codeParamIDs := make([]Code, 0)
					for i := range paramZeroVals {
						isConsidered := IntSliceContains(parameterIndexes, i)
						if isConsidered {
							codeParamIDs = append(codeParamIDs, Id(fe.Parameters[i].VarName).Op(",").Line())
						}
					}
					groupCase.Comment("Sink parameters:")
					groupCase.Id("sink").Call(Line().Add(codeParamIDs...).Line())
				}
				// Sink the results:
				if len(resultIndexes) > 0 {
					codeResultIDs := make([]Code, 0)
					for i := range resultZeroVals {
						isConsidered := IntSliceContains(resultIndexes, i)
						if isConsidered {
							codeResultIDs = append(codeResultIDs, Id(fe.Results[i].VarName).Op(",").Line())
						}
					}
					groupCase.Comment("Sink results:")
					groupCase.Id("sink").Call(Line().Add(codeResultIDs...).Line())
				}
			}
		})

	codeElements = append(codeElements,
		code,
	)

	return fn, codeElements
}
