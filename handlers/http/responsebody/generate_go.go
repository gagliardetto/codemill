package responsebody

import (
	"go/types"
	"os"
	"path/filepath"
	"sort"

	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/codebox/gogentools"
	"github.com/gagliardetto/codemill/x"
	"github.com/gagliardetto/feparser"
	. "github.com/gagliardetto/utilz"
)

const (
	// NOTE: hardcoded inside TestQueryContent const.
	InlineExpectationsTestTagResponseBody = "$responseBody" // Must start with a $ sign.
	InlineExpectationsTestTagContentType  = "$contentType"  // Must start with a $ sign.
)

func TagResponseBody(vals ...string) string {
	tg := ""
	for i, v := range vals {
		if i > 0 {
			tg += " "
		}
		tg += InlineExpectationsTestTagResponseBody + "=" + v
	}
	return tg
}

func TagContentType(vals ...string) string {
	tg := ""
	for i, v := range vals {
		if i > 0 {
			tg += " "
		}
		tg += InlineExpectationsTestTagContentType + "=" + v
	}
	return tg
}
func Tag(contentTypes string, respBodies string) Code {
	if contentTypes == "" {
		return Comment(respBodies)
	}
	return Comment(contentTypes + " " + respBodies)
}

const (
	TestQueryContent = `
import go
import TestUtilities.InlineExpectationsTest

class HttpResponseBodyTest extends InlineExpectationsTest {
  HttpResponseBodyTest() { this = "HttpResponseBodyTest" }

  override string getARelevantTag() { result = ["contentType", "responseBody"] }

  override predicate hasActualResult(string file, int line, string element, string tag, string value) {
    exists(HTTP::ResponseBody rd |
      rd.hasLocationInfo(file, line, _, _, _) and
      (
        element = rd.getAContentType().toString() and
        value = rd.getAContentType().toString() and
        tag = "contentType"
        or
        element = rd.toString() and
        value = rd.toString() and
        tag = "responseBody"
      )
    )
  }
}
`
)

func NewTestFile(includeBoilerplace bool) *File {
	file := NewFile("main")
	// Set a prefix to avoid collision between variable names and packages:
	file.PackagePrefix = "cql"
	// Add comment to file:
	file.HeaderComment("Code generated by https://github.com/gagliardetto. DO NOT EDIT.")

	if includeBoilerplace {
		{
			// main function:
			file.Func().Id("main").Params().Block()
		}
		{
			// The `source` function:
			code := Func().
				Id("source").
				Params().
				Interface().
				Block(Return(Nil()))
			file.Add(code.Line())
		}
	}
	return file
}

var (
	IncludeCommentsInGeneratedGo bool
)

// Comments adds comments to a Group (if enabled), and returns the group.
func Comments(group *Group, comments ...string) *Group {
	if IncludeCommentsInGeneratedGo {
		for _, comment := range comments {
			group.Line().Comment(comment)
		}
	}
	return group
}

func newStatement() *Statement {
	return &Statement{}
}

// declare `name := source(1).(Type)`
func ComposeTypeAssertion(file *File, group *Group, varName string, typ types.Type, isVariadic bool) {
	assertContent := newStatement()
	if isVariadic {
		if slice, ok := typ.(*types.Slice); ok {
			gogentools.ComposeTypeDeclaration(file, assertContent, slice.Elem())
		} else {
			gogentools.ComposeTypeDeclaration(file, assertContent, typ)
		}
	} else {
		gogentools.ComposeTypeDeclaration(file, assertContent, typ)
	}
	group.Id(varName).Op(":=").Id("source").Call().Assert(assertContent)
}

func (han *Handler) GenerateGo(parentDir string, mdl *x.XModel) error {
	if err := mdl.Validate(); err != nil {
		return err
	}
	if err := han.Validate(mdl); err != nil {
		return err
	}
	// TODO:
	// - Validate Pos.

	// Check if there are multiple versions of a same package:
	mods := mdl.ListModules()
	if x.HasMultiversion(mods) {
		Ln(RedBG("Has multiversion"))
	}
	// If there are no multiple versions of the same module,
	// that means we can save all the code to one file.
	allInOneFile := !x.HasMultiversion(mods)

	// Create the directory for the tests for this model:
	outDir := filepath.Join(parentDir, feparser.NewCodeQlName(mdl.Name))
	MustCreateFolderIfNotExists(outDir, os.ModePerm)

	allPathVersions := func() []string {
		res := make([]string, 0)
		mods := mdl.ListModules()
		for _, mod := range mods {
			res = append(res, mod.PathVersionClean())
		}
		sort.Strings(res)
		return res
	}()

	file := NewTestFile(true)

	for _, pathVersion := range allPathVersions {
		if !allInOneFile {
			// Reset file:
			file = NewTestFile(true)
		}
		pathCodez := make([]Code, 0)
		{
			{
				pc := go_MethodBodyWithCtFromFuncName(mdl, file, pathVersion)
				pathCodez = append(pathCodez, pc...)
			}
			{
				pc := go_MethodBodyWithCt(mdl, file, pathVersion)
				pathCodez = append(pathCodez, pc...)
			}
			{
				pc := go_body_ct(mdl, file, pathVersion)
				pathCodez = append(pathCodez, pc...)
			}
		}

		{
			file.Commentf("Package %s", pathVersion)
			file.Func().Id(feparser.FormatCodeQlName(pathVersion)).Params().Block(pathCodez...)
		}

		if !allInOneFile {
			file.PackageComment("//go:generate depstubber --vendor --auto")

			pkgDstDirpath := filepath.Join(outDir, feparser.FormatID("Model", mdl.Name, "For", feparser.FormatCodeQlName(pathVersion)))
			MustCreateFolderIfNotExists(pkgDstDirpath, os.ModePerm)

			assetFileName := feparser.FormatID("Model", mdl.Name, "For", feparser.FormatCodeQlName(pathVersion)) + ".go"
			if err := x.SaveGoFile(pkgDstDirpath, assetFileName, file); err != nil {
				Fatalf("Error while saving go file: %s", err)
			}

			if err := x.WriteGoModFile(pkgDstDirpath, pathVersion); err != nil {
				Fatalf("Error while saving go.mod file: %s", err)
			}
			if err := x.WriteCodeQLTestQuery(pkgDstDirpath, x.DefaultCodeQLTestFileName, TestQueryContent); err != nil {
				Fatalf("Error while saving <name>.ql file: %s", err)
			}
			if err := x.WriteEmptyCodeQLDotExpectedFile(pkgDstDirpath, x.DefaultCodeQLTestFileName); err != nil {
				Fatalf("Error while saving <name>.expected file: %s", err)
			}
		}
	}

	if allInOneFile {
		file.PackageComment("//go:generate depstubber --vendor --auto")

		pkgDstDirpath := outDir
		MustCreateFolderIfNotExists(pkgDstDirpath, os.ModePerm)

		assetFileName := feparser.FormatID("Model", mdl.Name) + ".go"
		if err := x.SaveGoFile(pkgDstDirpath, assetFileName, file); err != nil {
			Fatalf("Error while saving go file: %s", err)
		}

		if err := x.WriteGoModFile(pkgDstDirpath, allPathVersions...); err != nil {
			Fatalf("Error while saving go.mod file: %s", err)
		}
		if err := x.WriteCodeQLTestQuery(pkgDstDirpath, x.DefaultCodeQLTestFileName, TestQueryContent); err != nil {
			Fatalf("Error while saving <name>.ql file: %s", err)
		}
		if err := x.WriteEmptyCodeQLDotExpectedFile(pkgDstDirpath, x.DefaultCodeQLTestFileName); err != nil {
			Fatalf("Error while saving <name>.expected file: %s", err)
		}
	}
	return nil
}

func go_MethodBodyWithCtFromFuncName(mdl *x.XModel, file *File, pathVersion string) []Code {

	method := mdl.Methods.ByName(MethodBodyWithCtFromFuncName)

	if len(method.Selectors) == 0 {
		Infof("No selectors found for %q method.", method.Name)
		return nil
	}

	b2fe, b2tm, b2itm, err := x.GroupFuncSelectors(method)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}

	codez := make([]Code, 0)
	{
		cont, ok := b2fe[pathVersion]
		if ok && x.HasValidPos(cont...) {
			code := BlockFunc(
				func(groupCase *Group) {

					for _, funcQual := range cont {
						fn := x.GetFuncQualifier(funcQual)
						thing := fn.(*feparser.FEFunc)

						x.AddImportsFromFunc(file, thing)

						{
							if AllFalse(funcQual.Pos...) {
								continue
							}
							groupCase.Comment(thing.Signature)

							blocksOfCases := par_MethodBodyWithCtFromFuncName_generateGoTestBlock(
								file,
								thing,
								funcQual,
							)
							if len(blocksOfCases) == 1 {
								groupCase.Add(blocksOfCases...)
							} else {
								groupCase.Block(blocksOfCases...)
							}
						}

					}
				})
			codez = append(codez,
				Comment("Response body is set via a function call (the content-type is implicit in the function name).").
					Line().
					Add(code),
			)
		}
	}
	{
		cont, ok := b2tm[pathVersion]
		if ok {
			codezTypeMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, methodQual := range methodQualifiers {
							fn := x.GetFuncQualifier(methodQual)
							thing := fn.(*feparser.FETypeMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(methodQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								blocksOfCases := par_MethodBodyWithCtFromFuncName_generateGoTestBlock(
									file,
									thing,
									methodQual,
								)
								if len(blocksOfCases) == 1 {
									groupCase.Add(blocksOfCases...)
								} else {
									groupCase.Block(blocksOfCases...)
								}
							}

						}
					})
				// TODO: what if no flows are enabled? Check that before adding the comment.
				codezTypeMethods = append(codezTypeMethods,
					Commentf("Response body is set via a method call on the %s type (the content-type is implicit in the method name).", typ.QualifiedName).
						Line().
						Add(code),
				)
			}
			codez = append(codez,
				Comment("Response body is set via a method call (the content-type is implicit in the method name).").
					Line().
					Block(codezTypeMethods...),
			)
		}
	}

	{
		cont, ok := b2itm[pathVersion]
		if ok {
			codezIfaceMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, methodQual := range methodQualifiers {
							fn := x.GetFuncQualifier(methodQual)
							thing := fn.(*feparser.FEInterfaceMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(methodQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								converted := feparser.FEIToFET(thing)
								blocksOfCases := par_MethodBodyWithCtFromFuncName_generateGoTestBlock(
									file,
									converted,
									methodQual,
								)
								if len(blocksOfCases) == 1 {
									groupCase.Add(blocksOfCases...)
								} else {
									groupCase.Block(blocksOfCases...)
								}
							}
						}
					})
				codezIfaceMethods = append(codezIfaceMethods,
					Commentf("Response body is set via a method call on the %s interface (the content-type is implicit in the method name).", typ.QualifiedName).
						Line().
						Add(code),
				)
			}

			codez = append(codez,
				Comment("Response body is set via an interface method call (the content-type is implicit in the method name).").
					Line().
					Block(codezIfaceMethods...),
			)
		}
	}
	return codez
}

func par_MethodBodyWithCtFromFuncName_generateGoTestBlock(file *File, fn x.FuncInterface, qual *x.FuncQualifier) []Code {
	childBlocks := make([]Code, 0)

	indexes := x.MustPosToRelativeParamIndexes(fn, qual.Pos)

	childBlock := par_MethodBodyWithCtFromFuncName_generate(
		file,
		fn,
		indexes,
	)
	{
		if childBlock != nil {
			childBlocks = append(childBlocks, childBlock)
		} else {
			Warnf(Sf("NOTHING GENERATED; pos %v, param indexes %v", qual.Pos, indexes))
		}
	}

	return childBlocks
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func par_MethodBodyWithCtFromFuncName_generate(file *File, fn x.FuncInterface, indexes []int) *Statement {

	for _, index := range indexes {
		in := fn.GetFunc().Parameters[index]

		in.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("body", in.TypeName))
	}

	varNames := make([]string, 0)
	for _, index := range indexes {
		in := fn.GetFunc().Parameters[index]

		varNames = append(varNames, in.VarName)
	}

	hasReceiver := fn.GetReceiver() != nil

	code := BlockFunc(
		func(groupCase *Group) {

			for _, index := range indexes {
				in := fn.GetFunc().Parameters[index]

				ComposeTypeAssertion(file, groupCase, in.VarName, in.GetOriginal().GetType(), in.GetOriginal().IsVariadic())
			}

			if hasReceiver {
				groupCase.Var().Id("rece").Qual(fn.GetReceiver().PkgPath, fn.GetReceiver().TypeName)
			}

			gogentools.ImportPackage(file, fn.GetFunc().PkgPath, fn.GetFunc().PkgName)

			var after *Statement
			if hasReceiver {
				after = groupCase.Id("rece").Dot(fn.GetFunc().Name)
			} else {
				after = groupCase.Qual(fn.GetFunc().PkgPath, fn.GetFunc().Name)
			}

			after.CallFunc(
				func(call *Group) {

					tpFun := fn.GetFunc().GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fn.GetFunc().GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := IntSliceContains(indexes, i)
						if isConsidered {
							call.Id(fn.GetFunc().Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			).Add(Tag(TagContentType(guessContentTypeFromFuncName(fn.GetFunc().Name)), TagResponseBody(varNames...)))

		})
	return code
}

////////////////

func go_MethodBodyWithCt(mdl *x.XModel, file *File, pathVersion string) []Code {

	mtdBodyWithCtIsBody := mdl.Methods.ByName(MethodBodyWithCtIsBody)
	if len(mtdBodyWithCtIsBody.Selectors) == 0 {
		Infof("No selectors found for %q method.", mtdBodyWithCtIsBody.Name)
		return nil
	}

	b2feBody, b2tmBody, b2itmBody, err := x.GroupFuncSelectors(mtdBodyWithCtIsBody)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}
	//
	mtdBodyWithCtIsCt := mdl.Methods.ByName(MethodBodyWithCtIsCt)
	if len(mtdBodyWithCtIsCt.Selectors) == 0 {
		Infof("No selectors found for %q method.", mtdBodyWithCtIsCt.Name)
		return nil
	}

	b2feCt, b2tmCt, b2itmCt, err := x.GroupFuncSelectors(mtdBodyWithCtIsCt)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}

	codez := make([]Code, 0)
	{
		cont, ok := b2feBody[pathVersion]
		if ok && x.HasValidPos(cont...) {
			code := BlockFunc(
				func(groupCase *Group) {

					for _, bodyQual := range cont {
						fn := x.GetFuncQualifier(bodyQual)
						thing := fn.(*feparser.FEFunc)

						x.AddImportsFromFunc(file, thing)

						{
							if AllFalse(bodyQual.Pos...) {
								continue
							}
							groupCase.Comment(thing.Signature)

							ctQual := b2feCt[pathVersion].ByBasicQualifier(bodyQual.BasicQualifier)

							blocksOfCases := par_MethodBodyWithCt_generateGoTestBlock(
								file,
								thing,
								bodyQual,
								ctQual,
							)
							if len(blocksOfCases) == 1 {
								groupCase.Add(blocksOfCases...)
							} else {
								groupCase.Block(blocksOfCases...)
							}
						}

					}
				})
			codez = append(codez,
				Comment("Response body and content-type are both set via a single call of a function.").
					Line().
					Add(code),
			)
		}
	}
	{
		cont, ok := b2tmBody[pathVersion]
		if ok {
			codezTypeMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, bodyQual := range methodQualifiers {
							fn := x.GetFuncQualifier(bodyQual)
							thing := fn.(*feparser.FETypeMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(bodyQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								ctQual := b2tmCt[pathVersion][receiverTypeID].ByBasicQualifier(bodyQual.BasicQualifier)

								blocksOfCases := par_MethodBodyWithCt_generateGoTestBlock(
									file,
									thing,
									bodyQual,
									ctQual,
								)
								if len(blocksOfCases) == 1 {
									groupCase.Add(blocksOfCases...)
								} else {
									groupCase.Block(blocksOfCases...)
								}
							}

						}
					})
				// TODO: what if no flows are enabled? Check that before adding the comment.
				codezTypeMethods = append(codezTypeMethods,
					Commentf("Response body and content-type are both set via a single call of a method on the %s type.", typ.QualifiedName).
						Line().
						Add(code),
				)
			}
			codez = append(codez,
				Comment("Response body and content-type are both set via a single call of a method.").
					Line().
					Block(codezTypeMethods...),
			)
		}
	}

	{
		cont, ok := b2itmBody[pathVersion]
		if ok {
			codezIfaceMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, bodyQual := range methodQualifiers {
							fn := x.GetFuncQualifier(bodyQual)
							thing := fn.(*feparser.FEInterfaceMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(bodyQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								converted := feparser.FEIToFET(thing)

								ctQual := b2itmCt[pathVersion][receiverTypeID].ByBasicQualifier(bodyQual.BasicQualifier)

								blocksOfCases := par_MethodBodyWithCt_generateGoTestBlock(
									file,
									converted,
									bodyQual,
									ctQual,
								)
								if len(blocksOfCases) == 1 {
									groupCase.Add(blocksOfCases...)
								} else {
									groupCase.Block(blocksOfCases...)
								}
							}
						}
					})
				codezIfaceMethods = append(codezIfaceMethods,
					Commentf("Response body and content-type are both set via a single call of a method on the %s interface.", typ.QualifiedName).
						Line().
						Add(code),
				)
			}

			codez = append(codez,
				Comment("Response body and content-type are both set via a single call of an interface method.").
					Line().
					Block(codezIfaceMethods...),
			)
		}
	}
	return codez
}

func par_MethodBodyWithCt_generateGoTestBlock(
	file *File,
	fn x.FuncInterface,
	bodyQual *x.FuncQualifier,
	ctQual *x.FuncQualifier,
) []Code {
	childBlocks := make([]Code, 0)

	// TODO: support here multiple bodies, too?
	bodyIndexes := x.MustPosToRelativeParamIndexes(fn, bodyQual.Pos)
	if len(bodyIndexes) != 1 {
		Fatalf("bodyIndexes len is not 1: %v", bodyQual)
	}
	ctIndexes := x.MustPosToRelativeParamIndexes(fn, ctQual.Pos)
	if len(ctIndexes) != 1 {
		Fatalf("ctIndexes len is not 1: %v", ctQual)
	}

	childBlock := par_MethodBodyWithCt_generate(
		file,
		fn,
		bodyIndexes[0],
		ctIndexes[0],
	)
	{
		if childBlock != nil {
			childBlocks = append(childBlocks, childBlock)
		} else {
			Warnf(Sf("NOTHING GENERATED; bodyQual %v, ctQual %v", bodyQual, ctQual))
		}
	}

	return childBlocks
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

func par_MethodBodyWithCt_generate(file *File, fn x.FuncInterface, bodyIndex int, ctIndex int) *Statement {

	bodyParam := fn.GetFunc().Parameters[bodyIndex]
	bodyParam.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("body", bodyParam.TypeName))

	ctParam := fn.GetFunc().Parameters[ctIndex]
	ctParam.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("contentType", ctParam.TypeName))

	hasReceiver := fn.GetReceiver() != nil

	ctValue := "application/json"

	code := BlockFunc(
		func(groupCase *Group) {

			ComposeTypeAssertion(file, groupCase, bodyParam.VarName, bodyParam.GetOriginal().GetType(), bodyParam.GetOriginal().IsVariadic())

			if ctParam.GetOriginal().TypeString() == "string" {
				groupCase.Id(ctParam.VarName).Op(":=").Lit(ctValue)
			} else {
				ComposeTypeAssertion(file, groupCase, ctParam.VarName, ctParam.GetOriginal().GetType(), ctParam.GetOriginal().IsVariadic())
				groupCase.Id(ctParam.VarName).Op("=").Lit(ctValue)
			}

			if hasReceiver {
				groupCase.Var().Id("rece").Qual(fn.GetReceiver().PkgPath, fn.GetReceiver().TypeName)
			}

			gogentools.ImportPackage(file, fn.GetFunc().PkgPath, fn.GetFunc().PkgName)

			var after *Statement
			if hasReceiver {
				after = groupCase.Id("rece").Dot(fn.GetFunc().Name)
			} else {
				after = groupCase.Qual(fn.GetFunc().PkgPath, fn.GetFunc().Name)
			}

			after.CallFunc(
				func(call *Group) {

					tpFun := fn.GetFunc().GetOriginal().GetType().(*types.Signature)

					zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), fn.GetFunc().GetOriginal().IsVariadic())

					for i, zero := range zeroVals {
						isConsidered := IntSliceContains([]int{bodyIndex, ctIndex}, i)
						if isConsidered {
							call.Id(fn.GetFunc().Parameters[i].VarName)
						} else {
							call.Add(zero)
						}
					}

				},
			).Add(Tag(TagContentType(ctValue), TagResponseBody(bodyParam.VarName)))

		})
	return code
}

func go_body_ct(mdl *x.XModel, file *File, pathVersion string) []Code {

	mtdBody := mdl.Methods.ByName(MethodBody)
	if len(mtdBody.Selectors) == 0 {
		Infof("No selectors found for %q method.", mtdBody.Name)
		return nil
	}
	b2feBody, b2tmBody, b2itmBody, err := x.GroupFuncSelectors(mtdBody)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}
	//
	mtdCt := mdl.Methods.ByName(MethodCt)
	if len(mtdCt.Selectors) == 0 {
		Infof("No selectors found for %q method.", mtdCt.Name)
		return nil
	}
	b2feCt, b2tmCt, b2itmCt, err := x.GroupFuncSelectors(mtdCt)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}
	//
	mtdCtFromFuncName := mdl.Methods.ByName(MethodCtFromFuncName)
	if len(mtdCtFromFuncName.Selectors) == 0 {
		Infof("No selectors found for %q method.", mtdCtFromFuncName.Name)
		return nil
	}
	b2feCtFromFuncName, b2tmCtFromFuncName, b2itmCtFromFuncName, err := x.GroupFuncSelectors(mtdCtFromFuncName)
	if err != nil {
		Fatalf("Error while GroupFuncSelectors: %s", err)
	}

	_, _, _ = b2feCtFromFuncName, b2tmCtFromFuncName, b2itmCtFromFuncName

	codez := make([]Code, 0)
	{
		cont, ok := b2feBody[pathVersion]
		if ok && x.HasValidPos(cont...) {
			code := BlockFunc(
				func(groupCase *Group) {

					for _, bodyQual := range cont {
						fn := x.GetFuncQualifier(bodyQual)
						thing := fn.(*feparser.FEFunc)

						x.AddImportsFromFunc(file, thing)

						{
							if AllFalse(bodyQual.Pos...) {
								continue
							}
							groupCase.Comment(thing.Signature)

							{
								// Create a test for each combination of body and ct:
								for _, ctQual := range b2feCt[pathVersion] {
									blocksOfCases := par_go_body_plus_ct(
										file,
										bodyQual,
										ctQual,
									)
									if len(blocksOfCases) == 1 {
										groupCase.Add(blocksOfCases...)
									} else {
										groupCase.Block(blocksOfCases...)
									}
								}

								// Create a test for each combination of body and ctFromName:
								for _, ctQual := range b2feCtFromFuncName[pathVersion] {
									blocksOfCases := par_go_body_plus_ctFromFuncName(
										file,
										bodyQual,
										ctQual,
									)
									if len(blocksOfCases) == 1 {
										groupCase.Add(blocksOfCases...)
									} else {
										groupCase.Block(blocksOfCases...)
									}
								}
							}

						}

					}
				})
			codez = append(codez,
				Comment("Response body and content-type are set via calls of different functions.").
					Line().
					Add(code),
			)
		}
	}
	{
		cont, ok := b2tmBody[pathVersion]
		if ok {
			codezTypeMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, bodyQual := range methodQualifiers {
							fn := x.GetFuncQualifier(bodyQual)
							thing := fn.(*feparser.FETypeMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(bodyQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								{
									// Create a test for each combination of body and ct:
									for _, ctQual := range b2tmCt[pathVersion][receiverTypeID] {
										blocksOfCases := par_go_body_plus_ct(
											file,
											bodyQual,
											ctQual,
										)
										if len(blocksOfCases) == 1 {
											groupCase.Add(blocksOfCases...)
										} else {
											groupCase.Block(blocksOfCases...)
										}
									}

									// Create a test for each combination of body and ctFromName:
									for _, ctQual := range b2tmCtFromFuncName[pathVersion][receiverTypeID] {
										blocksOfCases := par_go_body_plus_ctFromFuncName(
											file,
											bodyQual,
											ctQual,
										)
										if len(blocksOfCases) == 1 {
											groupCase.Add(blocksOfCases...)
										} else {
											groupCase.Block(blocksOfCases...)
										}
									}
								}

							}

						}
					})
				// TODO: what if no flows are enabled? Check that before adding the comment.
				codezTypeMethods = append(codezTypeMethods,
					Commentf("Response body and content-type are set via calls of different methods on the %s type.", typ.QualifiedName).
						Line().
						Add(code),
				)
			}
			codez = append(codez,
				Comment("Response body and content-type are set via calls of different methods.").
					Line().
					Block(codezTypeMethods...),
			)
		}
	}

	{
		cont, ok := b2itmBody[pathVersion]
		if ok {
			codezIfaceMethods := make([]Code, 0)
			keys := func(v map[string]x.FuncQualifierSlice) []string {
				res := make([]string, 0)
				for key := range v {
					res = append(res, key)
				}
				sort.Strings(res)
				return res
			}(cont)
			for _, receiverTypeID := range keys {
				methodQualifiers := cont[receiverTypeID]
				if len(methodQualifiers) == 0 || !x.HasValidPos(methodQualifiers...) {
					continue
				}

				qual := methodQualifiers[0]
				source := x.GetCachedSource(qual.Path, qual.Version)
				if source == nil {
					Fatalf("Source not found: %s@%s", qual.Path, qual.Version)
				}
				// Find receiver type:
				typ := x.FindTypeByID(source, receiverTypeID)
				if typ == nil {
					Fatalf("Type not found: %q", receiverTypeID)
				}

				gogentools.ImportPackage(file, typ.PkgPath, typ.PkgName)

				code := BlockFunc(
					func(groupCase *Group) {

						for _, bodyQual := range methodQualifiers {
							fn := x.GetFuncQualifier(bodyQual)
							thing := fn.(*feparser.FEInterfaceMethod)
							x.AddImportsFromFunc(file, fn)

							{
								if AllFalse(bodyQual.Pos...) {
									continue
								}
								groupCase.Comment(thing.Func.Signature)

								{
									// Create a test for each combination of body and ct:
									for _, ctQual := range b2itmCt[pathVersion][receiverTypeID] {
										blocksOfCases := par_go_body_plus_ct(
											file,
											bodyQual,
											ctQual,
										)
										if len(blocksOfCases) == 1 {
											groupCase.Add(blocksOfCases...)
										} else {
											groupCase.Block(blocksOfCases...)
										}
									}

									// Create a test for each combination of body and ctFromName:
									for _, ctQual := range b2itmCtFromFuncName[pathVersion][receiverTypeID] {
										blocksOfCases := par_go_body_plus_ctFromFuncName(
											file,
											bodyQual,
											ctQual,
										)
										if len(blocksOfCases) == 1 {
											groupCase.Add(blocksOfCases...)
										} else {
											groupCase.Block(blocksOfCases...)
										}
									}
								}
							}
						}
					})
				codezIfaceMethods = append(codezIfaceMethods,
					Commentf("Response body and content-type are set via calls of different methods on the %s interface.", typ.QualifiedName).
						Line().
						Add(code),
				)
			}

			codez = append(codez,
				Comment("Response body and content-type are set via calls of different interface methods.").
					Line().
					Block(codezIfaceMethods...),
			)
		}
	}
	return codez
}

func par_go_body_plus_ct(
	file *File,
	bodyQual *x.FuncQualifier,
	ctQual *x.FuncQualifier,
) []Code {

	childBlocks := make([]Code, 0)

	bodyFn := GetFunc(bodyQual)
	ctFn := GetFunc(ctQual)
	// TODO: support here multiple bodies, too?
	bodyIndexes := x.MustPosToRelativeParamIndexes(bodyFn, bodyQual.Pos)
	if len(bodyIndexes) != 1 {
		Fatalf("bodyIndexes len is not 1: %v", bodyQual)
	}
	ctIndexes := x.MustPosToRelativeParamIndexes(ctFn, ctQual.Pos)
	if len(ctIndexes) != 1 {
		Fatalf("ctIndexes len is not 1: %v", ctQual)
	}

	childBlock := par_go_body_plus_ct_generate(
		file,
		bodyFn,
		ctFn,
		bodyIndexes[0],
		ctIndexes[0],
	)
	{
		if childBlock != nil {
			childBlocks = append(childBlocks, childBlock)
		} else {
			Warnf(Sf("NOTHING GENERATED; bodyQual %v, ctQual %v", bodyQual, ctQual))
		}
	}

	return childBlocks
}
func par_go_body_plus_ct_generate(
	file *File,
	bodyFn x.FuncInterface,
	ctFn x.FuncInterface,
	bodyIndex int,
	ctIndex int,
) *Statement {

	bodyParam := bodyFn.GetFunc().Parameters[bodyIndex]
	bodyParam.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("body", bodyParam.TypeName))

	ctParam := ctFn.GetFunc().Parameters[ctIndex]
	ctParam.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("contentType", ctParam.TypeName))

	bodyFnHasReceiver := bodyFn.GetReceiver() != nil
	ctFnHasReceiver := ctFn.GetReceiver() != nil
	// TODO: they must have the same receiver?

	ctValue := "application/json"

	code := BlockFunc(
		func(groupCase *Group) {

			ComposeTypeAssertion(file, groupCase, bodyParam.VarName, bodyParam.GetOriginal().GetType(), bodyParam.GetOriginal().IsVariadic())

			if ctParam.GetOriginal().TypeString() == "string" {
				groupCase.Id(ctParam.VarName).Op(":=").Lit(ctValue)
			} else {
				ComposeTypeAssertion(file, groupCase, ctParam.VarName, ctParam.GetOriginal().GetType(), ctParam.GetOriginal().IsVariadic())
				groupCase.Id(ctParam.VarName).Op("=").Lit(ctValue)
			}

			if bodyFnHasReceiver {
				groupCase.Var().Id("rece").Qual(bodyFn.GetReceiver().PkgPath, bodyFn.GetReceiver().TypeName)
			}

			gogentools.ImportPackage(file, bodyFn.GetFunc().PkgPath, bodyFn.GetFunc().PkgName)
			gogentools.ImportPackage(file, ctFn.GetFunc().PkgPath, ctFn.GetFunc().PkgName)

			{
				var afterCt *Statement
				if ctFnHasReceiver {
					// NOTE: this assumes that both functions are methods on the same receiver.
					afterCt = groupCase.Id("rece").Dot(ctFn.GetFunc().Name)
				} else {
					afterCt = groupCase.Qual(ctFn.GetFunc().PkgPath, ctFn.GetFunc().Name)
				}
				afterCt.CallFunc(
					func(call *Group) {

						tpFun := ctFn.GetFunc().GetOriginal().GetType().(*types.Signature)

						zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), ctFn.GetFunc().GetOriginal().IsVariadic())

						for i, zero := range zeroVals {
							isConsidered := IntSliceContains([]int{ctIndex}, i)
							if isConsidered {
								call.Id(ctFn.GetFunc().Parameters[i].VarName)
							} else {
								call.Add(zero)
							}
						}
					},
				)
			}

			{
				var afterBody *Statement
				if bodyFnHasReceiver {
					afterBody = groupCase.Id("rece").Dot(bodyFn.GetFunc().Name)
				} else {
					afterBody = groupCase.Qual(bodyFn.GetFunc().PkgPath, bodyFn.GetFunc().Name)
				}
				afterBody.CallFunc(
					func(call *Group) {

						tpFun := bodyFn.GetFunc().GetOriginal().GetType().(*types.Signature)

						zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), bodyFn.GetFunc().GetOriginal().IsVariadic())

						for i, zero := range zeroVals {
							isConsidered := IntSliceContains([]int{bodyIndex}, i)
							if isConsidered {
								call.Id(bodyFn.GetFunc().Parameters[i].VarName)
							} else {
								call.Add(zero)
							}
						}

					},
				).Add(Tag(TagContentType(ctValue), TagResponseBody(bodyParam.VarName)))
			}

		})
	return code
}
func par_go_body_plus_ctFromFuncName(
	file *File,
	bodyQual *x.FuncQualifier,
	ctQual *x.FuncQualifier,
) []Code {

	childBlocks := make([]Code, 0)

	bodyFn := GetFunc(bodyQual)
	ctFn := GetFunc(ctQual)
	// TODO: support here multiple bodies, too?
	bodyIndexes := x.MustPosToRelativeParamIndexes(bodyFn, bodyQual.Pos)
	if len(bodyIndexes) != 1 {
		Fatalf("bodyIndexes len is not 1: %v", bodyQual)
	}

	childBlock := par_go_body_plus_ctFromFuncName_generate(
		file,
		bodyFn,
		ctFn,
		bodyIndexes[0],
	)
	{
		if childBlock != nil {
			childBlocks = append(childBlocks, childBlock)
		} else {
			Warnf(Sf("NOTHING GENERATED; bodyQual %v, ctQual %v", bodyQual, ctQual))
		}
	}

	return childBlocks
}
func par_go_body_plus_ctFromFuncName_generate(
	file *File,
	bodyFn x.FuncInterface,
	ctFn x.FuncInterface,
	bodyIndex int,
) *Statement {

	bodyParam := bodyFn.GetFunc().Parameters[bodyIndex]
	bodyParam.VarName = gogentools.NewNameWithPrefix(feparser.NewLowerTitleName("body", bodyParam.TypeName))

	bodyFnHasReceiver := bodyFn.GetReceiver() != nil
	ctFnHasReceiver := ctFn.GetReceiver() != nil
	// TODO: they must have the same receiver?

	code := BlockFunc(
		func(groupCase *Group) {

			ComposeTypeAssertion(file, groupCase, bodyParam.VarName, bodyParam.GetOriginal().GetType(), bodyParam.GetOriginal().IsVariadic())

			if bodyFnHasReceiver {
				groupCase.Var().Id("rece").Qual(bodyFn.GetReceiver().PkgPath, bodyFn.GetReceiver().TypeName)
			}

			gogentools.ImportPackage(file, bodyFn.GetFunc().PkgPath, bodyFn.GetFunc().PkgName)
			gogentools.ImportPackage(file, ctFn.GetFunc().PkgPath, ctFn.GetFunc().PkgName)

			{
				var afterCt *Statement
				if ctFnHasReceiver {
					// NOTE: this assumes that both functions are methods on the same receiver.
					afterCt = groupCase.Id("rece").Dot(ctFn.GetFunc().Name)
				} else {
					afterCt = groupCase.Qual(ctFn.GetFunc().PkgPath, ctFn.GetFunc().Name)
				}
				afterCt.Call()
			}

			{
				var afterBody *Statement
				if bodyFnHasReceiver {
					afterBody = groupCase.Id("rece").Dot(bodyFn.GetFunc().Name)
				} else {
					afterBody = groupCase.Qual(bodyFn.GetFunc().PkgPath, bodyFn.GetFunc().Name)
				}
				afterBody.CallFunc(
					func(call *Group) {

						tpFun := bodyFn.GetFunc().GetOriginal().GetType().(*types.Signature)

						zeroVals := gogentools.ScanTupleOfZeroValues(file, tpFun.Params(), bodyFn.GetFunc().GetOriginal().IsVariadic())

						for i, zero := range zeroVals {
							isConsidered := IntSliceContains([]int{bodyIndex}, i)
							if isConsidered {
								call.Id(bodyFn.GetFunc().Parameters[i].VarName)
							} else {
								call.Add(zero)
							}
						}

					},
				).Add(Tag(TagContentType(guessContentTypeFromFuncName(ctFn.GetFunc().Name)), TagResponseBody(bodyParam.VarName)))
			}

		})
	return code
}
